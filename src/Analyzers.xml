<?xml version="1.0" encoding="utf-8"?>
<Analyzers>
  <Analyzer>
    <Id>RCS0001</Id>
    <Identifier>AddBlankLineAfterEmbeddedStatement</Identifier>
    <Title>Add blank line after embedded statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
    Foo();
Bar();]]></Before>
        <After><![CDATA[if (x)
    Foo();

Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0002</Id>
    <Identifier>AddBlankLineAfterRegionDirective</Identifier>
    <Title>Add blank line after #region</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    #region Methods
    void M()
    {
    }
    
    #endregion
}]]></Before>
        <After><![CDATA[class C
{
    #region Methods

    void M()
    {
    }
    
    #endregion
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0003</Id>
    <Identifier>AddBlankLineAfterUsingDirectiveList</Identifier>
    <Title>Add blank line after using directive list</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Copyright ...

using System;
using System.Linq;
namespace N
{
}]]></Before>
        <After><![CDATA[// Copyright ...

using System;
using System.Linq;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0004</Id>
    <Identifier>AddEmptyLineBeforeClosingBraceOfDoStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Add empty line before closing brace of 'do' statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
} while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();

} while (x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0005</Id>
    <Identifier>AddBlankLineBeforeEndRegionDirective</Identifier>
    <Title>Add blank line before #endregion</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    #region Methods
    
    void M()
    {
    }
    #endregion
}]]></Before>
        <After><![CDATA[class C
{
    #region Methods

    void M()
    {
    }
    
    #endregion
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0006</Id>
    <Identifier>AddBlankLineBeforeUsingDirectiveList</Identifier>
    <Title>Add blank line before using directive list</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Copyright ...
using System;
using System.Linq;

namespace N
{
}]]></Before>
        <After><![CDATA[// Copyright ...

using System;
using System.Linq;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0007</Id>
    <Identifier>AddBlankLineBetweenAccessors</Identifier>
    <Title>Add blank line between accessors</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string P
{
    get
    {
        return _p;
    }
    set
    {
        _p = value;
    }
}]]></Before>
        <After><![CDATA[string P
{
    get
    {
        return _p;
    }

    set
    {
        _p = value;
    }
}]]></After>
      </Sample>
    </Samples>
    <Remarks>This rule does not enforce an blank line between two single-line accessors.</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS0008</Id>
    <Identifier>AddBlankLineBetweenClosingBraceAndNextStatement</Identifier>
    <Title>Add blank line between closing brace and next statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
}
Foo();]]></Before>
        <After><![CDATA[if (x)
{
}

Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0009</Id>
    <Identifier>AddBlankLineBetweenDeclarationAndDocumentationComment</Identifier>
    <Title>Add blank line between declaration and documentation comment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object P1 { get; }
/// <summary>
/// ...
/// </summary>
object P2 { get; }]]></Before>
        <After><![CDATA[object P1 { get; }

/// <summary>
/// ...
/// </summary>
object P2 { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0010</Id>
    <Identifier>AddBlankLineBetweenDeclarations</Identifier>
    <Title>Add blank line between declarations</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
{
    void M1()
    {
    }
    void M2()
    {
    }
    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }
    string P1 { get; set; }
    [Obsolete]
    string P2 { get; set; }
}
enum Bar
{
    A = 0,
    /// <summary>
    /// ...
    /// </summary>
    B = 1,
    [Obsolete]
    C = 2,
}]]></Before>
        <After><![CDATA[class Foo
{
    void M1()
    {
    }

    void M2()
    {
    }

    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }

    string P1 { get; set; }

    [Obsolete]
    string P2 { get; set; }
}

enum Bar
{
    A = 0,

    /// <summary>
    /// ...
    /// </summary>
    B = 1,

    [Obsolete]
    C = 2,
}]]></After>
      </Sample>
    </Samples>
    <Remarks>This rule does not enforce an blank line between two single-line declaration.</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS0011</Id>
    <Identifier>BlankLineBetweenSingleLineAccessors</Identifier>
    <Title>Add/remove blank line between single-line accessors</Title>
    <MessageFormat>{0} blank line between single-line accessors</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string P
{
    get { return _p; }
    set { _p = value; }
}]]></Before>
        <After><![CDATA[string P
{
    get { return _p; }
    
    set { _p = value; }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_single_line_accessors" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0012</Id>
    <Identifier>AddBlankLineBetweenSingleLineDeclarations</Identifier>
    <Title>Add blank line between single-line declarations</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object P1 { get; }
object P2 { get; }]]></Before>
        <After><![CDATA[object P1 { get; }

object P2 { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0013</Id>
    <Identifier>AddBlankLineBetweenSingleLineDeclarationsOfDifferentKind</Identifier>
    <Title>Add blank line between single-line declarations of different kind</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object P { get; }
object this[int index] { get; }]]></Before>
        <After><![CDATA[object P { get; }

object this[int index] { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0014</Id>
    <Identifier>AddBlankLineBetweenSwitchSections</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS0061 instead</ObsoleteMessage>
    <Title>Add blank line between switch sections</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="blank_line_between_closing_brace_and_switch_section" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a":
        return A();
    case "b":
        return B();
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        return A();

    case "b":
        return B();
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0015</Id>
    <Identifier>BlankLineBetweenUsingDirectives</Identifier>
    <Title>Add/remove blank line between using directives</Title>
    <MessageFormat>{0} blank line between using directives</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
using Microsoft.CodeAnalysis;

namespace N
{
}]]></Before>
        <After><![CDATA[using System;

using Microsoft.CodeAnalysis;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_using_directives" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0016</Id>
    <Identifier>PutAttributeListOnItsOwnLine</Identifier>
    <Title>Put attribute list on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum Foo
{
    A,
    [Obsolete] B,
    C,
}]]></Before>
        <After><![CDATA[enum Foo
{
    A,
    [Obsolete]
    B,
    C,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0017</Id>
    <Identifier>AddNewLineAfterBinaryOperatorInsteadOfBeforeIt2</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line after binary operator instead of before it</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x
    && y
    && z)
{
}]]></Before>
        <After><![CDATA[if (x &&
    y &&
    z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0018</Id>
    <Identifier>AddNewLineAfterConditionalOperatorInsteadOfBeforeIt2</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line after conditional operator instead of before it</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = (x)
    ? Foo()
    : Bar();]]></Before>
        <After><![CDATA[var y = (x) ?
     Foo() :
     Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0019</Id>
    <Identifier>AddNewLineAfterExpressionBodyArrowInsteadOfBeforeIt2</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line after expression body arrow instead of before it</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object Foo()
    => null;]]></Before>
        <After><![CDATA[object Foo() =>
    null;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0020</Id>
    <Identifier>FormatAccessorBraces</Identifier>
    <Title>Format accessor's braces on a single line or multiple lines</Title>
    <MessageFormat>Format braces on {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="accessor_braces_style" IsRequired="true" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo
{
    get { return _foo; }
}]]></Before>
        <After><![CDATA[string Foo
{
    get
    {
        return _foo;
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0021</Id>
    <Identifier>FormatBlockBraces</Identifier>
    <Title>Format block's braces on a single line or multiple lines</Title>
    <MessageFormat>Format braces on {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="block_braces_style" IsRequired="true" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo() { Bar(); }]]></Before>
        <After><![CDATA[void Foo()
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0022</Id>
    <Identifier>AddNewLineAfterOpeningBraceOfEmptyBlock</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS0021 instead</ObsoleteMessage>
    <Title>Add new line after opening brace of empty block</Title>
    <MessageFormat>Format braces on multiple lines</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo()
{ }]]></Before>
        <After><![CDATA[void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0023</Id>
    <Identifier>FormatTypeDeclarationBraces</Identifier>
    <Title>Format type declaration's braces</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{ }]]></Before>
        <After><![CDATA[interface IFoo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0024</Id>
    <Identifier>AddNewLineAfterSwitchLabel</Identifier>
    <Title>Add new line after switch label</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a": return A();
    case "b": return B();
}]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        return A();
    case "b":
        return B();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0025</Id>
    <Identifier>PutFullAccessorOnItsOwnLine</Identifier>
    <Title>Put full accessor on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo { get { return _foo; } set { _foo = value; } }]]></Before>
        <After><![CDATA[string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0027</Id>
    <Identifier>PlaceNewLineAfterOrBeforeBinaryOperator</Identifier>
    <Title>Place new line after/before binary operator</Title>
    <MessageFormat>Place new line {0} binary operator</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x &&
    y &&
    z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="binary_operator_new_line" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0028</Id>
    <Identifier>PlaceNewLineAfterOrBeforeConditionalOperator</Identifier>
    <Title>Place new line after/before '?:' operator</Title>
    <MessageFormat>Place new line {0} operator</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = x ?
    Foo() :
    Bar();]]></Before>
        <After><![CDATA[var y = x
    ? Foo()
    : Bar();]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="conditional_operator_new_line" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0029</Id>
    <Identifier>PutConstructorInitializerOnItsOwnLine</Identifier>
    <Title>Put constructor initializer on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo(object p1, object p2) : base(p1)
{
    P2 = p2;
}]]></Before>
        <After><![CDATA[Foo(object p1, object p2)
    : base(p1)
{
    P2 = p2;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0030</Id>
    <Identifier>PutEmbeddedStatementOnItsOwnLine</Identifier>
    <Title>Put embedded statement on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x) Foo();]]></Before>
        <After><![CDATA[if (x)
    Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0031</Id>
    <Identifier>PutEnumMemberOnItsOwnLine</Identifier>
    <Title>Put enum member on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum Foo { A, B, C, }]]></Before>
        <After><![CDATA[enum Foo
{
    A,
    B,
    C,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0032</Id>
    <Identifier>PlaceNewLineAfterOrBeforeArrowToken</Identifier>
    <Title>Place new line after/before arrow token</Title>
    <MessageFormat>Place new line {0} arrow token</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object Foo() =>
    null;]]></Before>
        <After><![CDATA[object Foo()
    => null;]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="arrow_token_new_line" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0033</Id>
    <Identifier>PutStatementOnItsOwnLine</Identifier>
    <Title>Put statement on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo(); Bar();]]></Before>
        <After><![CDATA[Foo();
Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0034</Id>
    <Identifier>PutTypeParameterConstraintOnItsOwnLine</Identifier>
    <Title>Put type parameter constraint on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo<T1, T2> where T1 : struct where T2 : struct
{
}]]></Before>
        <After><![CDATA[class Foo<T1, T2>
    where T1 : struct
    where T2 : struct
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0035</Id>
    <Identifier>RemoveEmptyLineBetweenSingleLineAccessors2</Identifier>
    <Status>Disabled</Status>
    <Title>Remove empty line between single-line accessors</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string P
{
    get { return _p; }

    set { _p = value; }
}]]></Before>
        <After><![CDATA[string P
{
    get { return _p; }
    set { _p = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0036</Id>
    <Identifier>RemoveBlankLineBetweenSingleLineDeclarationsOfSameKind</Identifier>
    <Title>Remove blank line between single-line declarations of same kind</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Samples>
        <Sample>
          <Before><![CDATA[object P1 { get; }

object P2 { get; }]]></Before>
          <After><![CDATA[object P1 { get; }
object P2 { get; }]]></After>
        </Sample>
      </Samples>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0037</Id>
    <Identifier>RemoveEmptyLineBetweenUsingDirectivesWithDifferentRootNamespace2</Identifier>
    <Status>Disabled</Status>
    <Title>Remove empty line between using directives with different root namespace</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;

using Microsoft.CodeAnalysis;

namespace N
{
}]]></Before>
        <After><![CDATA[using System;
using Microsoft.CodeAnalysis;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0038</Id>
    <Identifier>RemoveBlankLineBetweenUsingDirectivesWithSameRootNamespace</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS0015 instead</ObsoleteMessage>
    <Title>Remove blank line between using directives with same root namespace</Title>
    <MessageFormat>Remove blank line between using directives</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;

using System.Linq;

namespace N
{
}]]></Before>
        <After><![CDATA[using System;
using System.Linq;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0039</Id>
    <Identifier>RemoveNewLineBeforeBaseList</Identifier>
    <Title>Remove new line before base list</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
    : Bar
{
}]]></Before>
        <After><![CDATA[class Foo : Bar
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0040</Id>
    <Identifier>RemoveNewLineBetweenClosingBraceAndWhileKeyword2</Identifier>
    <Status>Disabled</Status>
    <Title>Remove new line between closing brace and 'while' keyword</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
}
while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();
} while (x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0041</Id>
    <Identifier>RemoveNewLineBetweenIfKeywordAndElseKeyword</Identifier>
    <Title>Remove new line between 'if' keyword and 'else' keyword</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    Foo();
}
else
if (y)
{
    Bar();
}]]></Before>
        <After><![CDATA[if (x)
{
    Foo();
}
else if (y)
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0042</Id>
    <Identifier>PutAutoAccessorsOnSingleLine</Identifier>
    <Title>Put auto-accessors on a single line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo
{
    get;
    set;
}]]></Before>
        <After><![CDATA[string Foo { get; set; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0043</Id>
    <Identifier>FormatAccessorBracesOnSingleLineWhenExpressionIsOnSingleLine</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS0020 with option 'roslynator_accessor_braces_style = single_line_when_expression_is_on_single_line'</ObsoleteMessage>
    <Title>Format accessor's braces on a single line when expression is on single line</Title>
    <MessageFormat>Format braces on a single line</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo
{
    get
    {
        return _foo;
    }
    set
    {
        _foo = value;
    }
}]]></Before>
        <After><![CDATA[string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0044</Id>
    <Identifier>UseCarriageReturnAndLinefeedAsNewLine</Identifier>
    <Title>Use carriage return + linefeed as new line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS0045</Id>
    <Identifier>UseLinefeedAsNewLine</Identifier>
    <Title>Use linefeed as new line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS0046</Id>
    <Identifier>UseSpacesInsteadOfTab</Identifier>
    <Title>Use spaces instead of tab</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS0047</Id>
    <Identifier>WrapAndIndentEachNodeInList</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS0053 instead</ObsoleteMessage>
    <Title>Wrap and indent each node in list</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void M(object p1,
    object p2
    object p3) 
{
}]]></Before>
        <After><![CDATA[void M(
    object p1,
    object p2,
    object p3) 
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(
    object p1,
    object p2, object p3) 
{
}]]></Before>
        <After><![CDATA[void M(
    object p1,
    object p2,
    object p3) 
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0048</Id>
    <Identifier>PutInitializerOnSingleLine</Identifier>
    <Title>Put initializer on a single line</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var dic = new Dictionary<int, string>()
{
    { 0, "0" }
};]]></Before>
        <After><![CDATA[var dic = new Dictionary<int, string>() { { 0, "0" } };]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0049</Id>
    <Identifier>AddBlankLineAfterTopComment</Identifier>
    <Title>Add blank line after top comment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Copyright ...
using System;

namespace Foo
{
}]]></Before>
        <After><![CDATA[// Copyright ...

using System;

namespace Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0050</Id>
    <Identifier>AddBlankLineBeforeTopDeclaration</Identifier>
    <Title>Add blank line before top declaration</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
namespace Foo
{
}]]></Before>
        <After><![CDATA[using System;

namespace Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0051</Id>
    <Identifier>AddOrRemoveNewLineBeforeWhileInDoStatement</Identifier>
    <Title>Add/remove new line before 'while' in 'do' statement</Title>
    <MessageFormat>{0} new line before 'while' in 'do' statement</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
} while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();
}
while (x);]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="new_line_before_while_in_do_statement" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0052</Id>
    <Identifier>PlaceNewLineAfterOrBeforeEqualsToken</Identifier>
    <Title>Place new line after/before equals token</Title>
    <MessageFormat>Place new line {0} equals token</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s =
    new string(' ', 4);]]></Before>
        <After><![CDATA[string s
    = new string(' ', 4);]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="equals_token_new_line" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0053</Id>
    <Identifier>FixFormattingOfList</Identifier>
    <Title>Fix formatting of a list</Title>
    <MessageFormat>Fix formatting of {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>
      This analyzer:
* fixes indentation of argument/parameter list and similar lists
* formats each item in a multi-line list on a separate line

Following formats are considered as valid (for a parameter list):
```cs
void M(object x, object y)
{
}
```
```cs
void M(
    object x, object y)
{
}
```
```cs
void M(
    object x,
    object y)
{
}
```
</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[void M(
    object x,
        object y)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(object x,
    object y)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(object x,
       object y)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(
    object x,
    object y, object z)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y,
    object z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0054</Id>
    <Identifier>FixFormattingOfCallChain</Identifier>
    <Title>Fix formatting of a call chain</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer:
* fixes indentation of multi-line call chain
* formats each call on a separate line
</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[return [|x.M1()
    .M2().M3()|];]]></Before>
        <After><![CDATA[return [|x.M1()
    .M2()
    .M3()|];]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[return [|x.M1()
.M2()
.M3()|];]]></Before>
        <After><![CDATA[return [|x.M1()
    .M2()
    .M3()|];]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0055</Id>
    <Identifier>FixFormattingOfBinaryExpressionChain</Identifier>
    <Title>Fix formatting of a binary expression chain</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer:
 * fixes indentation of multi-line binary expression chain
 * formats each expression on a separate line
 </Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x && y
    && z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x
&& y
&& z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0056</Id>
    <Identifier>LineIsTooLong</Identifier>
    <Title>A line is too long</Title>
    <MessageFormat>A line is too long ({0} characters)</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer reports any line that is longer than maximum length.
    
Default maximum length is 140.</Summary>
    <ConfigOptions>
      <Option Key="max_line_length" />
      <Option Key="tab_length" />
    </ConfigOptions>
    <Remarks>Code fixer is available for this analyzer but it cannot handle all cases as it's not possible to wrap a line in all cases (e.g. long string literals).

If a particular line seems that it could be reasonably wrapped but it's not, please file an [issue](https://github.com/dotnet/roslynator/issues/new).
    </Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS0057</Id>
    <Identifier>NormalizeWhitespaceAtBeginningOfFile</Identifier>
    <Title>Normalize whitespace at the beginning of a file</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer enforces no whitespace at the beginning of a file.</Summary>
  </Analyzer>
  <Analyzer>
    <Id>RCS0058</Id>
    <Identifier>NormalizeWhitespaceAtEndOfFile</Identifier>
    <Title>Normalize whitespace at the end of a file</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer enforces:
* new line at the end of a file
* no new line at the end of a file if the option `roslynator.prefer_new_line_at_end_of_file` is set to `false`.</Summary>
    <ConfigOptions>
      <Option Key="new_line_at_end_of_file" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0059</Id>
    <Identifier>PlaceNewLineAfterOrBeforeNullConditionalOperator</Identifier>
    <Title>Place new line after/before null-conditional operator</Title>
    <MessageFormat>Place new line {0} null-conditional operator</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[items
    .Select(selector)
    .FirstOrDefault()
    ?.ToString()
    ]]></Before>
        <After><![CDATA[items
    .Select(selector)
    .FirstOrDefault()?
    .ToString()
    ]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="null_conditional_operator_new_line" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0060</Id>
    <Identifier>BlankLineAfterFileScopedNamespaceDeclaration</Identifier>
    <Title>Add/remove line after file scoped namespace declaration</Title>
    <MessageFormat>{0} line after file scoped namespace declaration</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>10.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[namespace A.B
public class C
{
}]]></Before>
        <After><![CDATA[namespace A.B

public class C
{
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_after_file_scoped_namespace_declaration" IsRequired="true" />
    </ConfigOptions>
    <Links>
      <Link>
        <Url>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/file-scoped-namespaces</Url>
        <Text>File Scoped Namespaces</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS0061</Id>
    <Identifier>BlankLineBetweenSwitchSections</Identifier>
    <Title>Add/remove blank line between switch sections</Title>
    <MessageFormat>{0} blank line between switch sections</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="blank_line_between_switch_sections" IsRequired="true" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <ConfigOptions>
          <Option Key="blank_line_between_switch_sections" Value="include" />
        </ConfigOptions>
        <Before><![CDATA[switch (x)
{
    case "foo":
        return true;
    case "bar":
        return false;
    default:
        throw new InvalidOperationException();
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "foo":
        return true;

    case "bar":
        return false;

    default:
        throw new InvalidOperationException();
}
]]></After>
      </Sample>
      <Sample>
        <ConfigOptions>
          <Option Key="blank_line_between_switch_sections" Value="omit" />
        </ConfigOptions>
        <Before><![CDATA[switch (x)
{
    case "foo":
        return true;

    case "bar":
        return false;

    default:
        throw new InvalidOperationException();
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "foo":
        return true;
    case "bar":
        return false;
    default:
        throw new InvalidOperationException();
}
]]></After>
      </Sample>
      <Sample>
        <ConfigOptions>
          <Option Key="blank_line_between_switch_sections" Value="omit_after_block" />
        </ConfigOptions>
        <Before><![CDATA[switch (x)
{
    case "foo":
      {
        return true;
      }

    case "bar":
      {
        return false;
      }
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "foo":
      {
        return true;
      }
    case "bar":
      {
        return false;
      }
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS0062</Id>
    <Identifier>PutExpressionBodyOnItsOwnLine</Identifier>
    <Title>Put expression body on its own line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object Foo() => null;]]></Before>
        <After><![CDATA[object Foo()
    => null;]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="arrow_token_new_line" IsRequired="false" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS0063</Id>
    <Identifier>RemoveUnnecessaryBlankLine</Identifier>
    <Title>Remove unnecessary blank line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{

    private string _f;


    public bool Bar()
    {

        return false;

    }

}]]></Before>
        <After><![CDATA[public class Foo
{
    private string _f;

    public bool Bar()
    {
        return false;
    }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_closing_brace_and_switch_section" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1001</Id>
    <Identifier>AddBracesWhenExpressionSpansOverMultipleLines</Identifier>
    <Title>Add braces (when expression spans over multiple lines)</Title>
    <MessageFormat>Add braces to {0} (when expression spans over multiple lines)</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    Foo(
        x,
        y);]]></Before>
        <After><![CDATA[if (condition)
{
    Foo(
        x,
        y);
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1002</Id>
    <Identifier>RemoveBraces</Identifier>
    <Title>Remove braces</Title>
    <MessageFormat>Remove braces from {0}</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    Foo();
}]]></Before>
        <After><![CDATA[if (condition)
    Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1003</Id>
    <Identifier>AddBracesToIfElseWhenExpressionSpansOverMultipleLines</Identifier>
    <Title>Add braces to if-else (when expression spans over multiple lines)</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    WhenTrue(
        x,
        y);
else
    WhenFalse(
        x,
        y);]]></Before>
        <After><![CDATA[if (condition)
{
    WhenTrue(
        x,
        y);
}
else
{
    WhenFalse(
        x,
        y);
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1004</Id>
    <Identifier>RemoveBracesFromIfElse</Identifier>
    <Title>Remove braces from if-else</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    WhenTrue();
}
else
{
    WhenFalse();
}]]></Before>
        <After><![CDATA[if (condition)
    WhenTrue();
else
    WhenFalse();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1005</Id>
    <Identifier>SimplifyNestedUsingStatement</Identifier>
    <Title>Simplify nested using statement</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[using (var fs = new FileStream("path", FileMode.OpenOrCreate))
{
    using (var sr = new StreamReader(fs))
    {
    }
}]]></Before>
        <After><![CDATA[using (var fs = new FileStream("path", FileMode.OpenOrCreate))
using (var sr = new StreamReader(fs))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1006</Id>
    <Identifier>MergeElseWithNestedIf</Identifier>
    <Title>Merge 'else' with nested 'if'</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition1)
{
    Foo1();
}
else
{
    if (condition2)
    {
        Foo2();
    }
}]]></Before>
        <After><![CDATA[if (condition1)
{
    Foo1();
}
else if (condition2)
{
    Foo2();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1007</Id>
    <Identifier>AddBraces</Identifier>
    <Title>Add braces</Title>
    <MessageFormat>Add braces to {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    Foo();]]></Before>
        <After><![CDATA[if (condition)
{
    Foo();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1008</Id>
    <Identifier>UseExplicitTypeInsteadOfVarWhenTypeIsNotObvious</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1264 instead</ObsoleteMessage>
    <Title>Use explicit type instead of 'var' (when the type is not obvious)</Title>
    <MessageFormat>Use explicit type instead of 'var'</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var s = GetValue();]]></Before>
        <After><![CDATA[string s = GetValue();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1009</Id>
    <Identifier>UseExplicitTypeInsteadOfVarInForEach</Identifier>
    <Title>Use explicit type instead of 'var' (foreach variable)</Title>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1264 instead</ObsoleteMessage>
    <MessageFormat>Use explicit type instead of 'var'</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<string>();

// ...

foreach (var item in items)
{
}]]></Before>
        <After><![CDATA[foreach (string item in items)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1010</Id>
    <Identifier>UseVarInsteadOfExplicitTypeWhenTypeIsObvious</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1264 instead</ObsoleteMessage>
    <Title>Use 'var' instead of explicit type (when the type is obvious)</Title>
    <MessageFormat>Use 'var' instead of explicit type</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo foo = new Foo();]]></Before>
        <After><![CDATA[var foo = new Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1012</Id>
    <Identifier>UseExplicitTypeInsteadOfVarWhenTypeIsObvious</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1264 instead</ObsoleteMessage>
    <Title>Use explicit type instead of 'var' (when the type is obvious)</Title>
    <MessageFormat>Use explicit type instead of 'var'</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var foo = new Foo();]]></Before>
        <After><![CDATA[Foo foo = new Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1013</Id>
    <Identifier>UsePredefinedType</Identifier>
    <Title>Use predefined type</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[String s = null;]]></Before>
        <After><![CDATA[string s = null;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1014</Id>
    <Identifier>UseExplicitlyOrImplicitlyTypedArray</Identifier>
    <Title>Use explicitly/implicitly typed array</Title>
    <MessageFormat>{0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new[] { "a", B };]]></Before>
        <After><![CDATA[var items = new string[] { "a", B };]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="array_creation_type_style" IsRequired="true" />
      <Option Key="use_collection_expression" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1015</Id>
    <Identifier>UseNameOfOperator</Identifier>
    <Title>Use nameof operator</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo(object parameter)
{
    if (parameter == null)
    {
        throw new ArgumentNullException("parameter", "message");
    }
}]]></Before>
        <After><![CDATA[public void Foo(object parameter)
{
    if (parameter == null)
    {
        throw new ArgumentNullException(nameof(parameter), "message");
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1016</Id>
    <Identifier>UseBlockBodyOrExpressionBody</Identifier>
    <Title>Use block body or expression body</Title>
    <MessageFormat>Use {0} body</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[public string Foo()
{
    return "";
}]]></Before>
        <After><![CDATA[public string Foo() => "";]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="body_style" IsRequired="true" />
      <Option Key="use_block_body_when_declaration_spans_over_multiple_lines" IsRequired="true" />
      <Option Key="use_block_body_when_expression_spans_over_multiple_lines" IsRequired="true" />
      <Option Key="arrow_token_new_line" IsRequired="false" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1017</Id>
    <Identifier>AvoidMultilineExpressionBody</Identifier>
    <Status>Disabled</Status>
    <Title>Avoid multiline expression body</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public string[] Foo() => new string[]
{
    "a",
    "b",
    "c"
};]]></Before>
        <After><![CDATA[public string[] Foo()
{
    return new string[]
    {
        "a",
        "b",
        "c"
    };
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1018</Id>
    <Identifier>AddOrRemoveAccessibilityModifiers</Identifier>
    <Title>Add/remove accessibility modifiers</Title>
    <MessageFormat>{0} accessibility modifiers</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
{
    void Bar()
    {
    }
}]]></Before>
        <After><![CDATA[internal class Foo
{
    private void Bar()
    {
    }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="accessibility_modifiers" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1019</Id>
    <Identifier>OrderModifiers</Identifier>
    <Title>Order modifiers</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private readonly static object _f;

internal protected class Foo
{
}]]></Before>
        <After><![CDATA[private static readonly object _f;

protected internal class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1020</Id>
    <Identifier>SimplifyNullableOfT</Identifier>
    <Title>Simplify Nullable&lt;T&gt; to T?</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[Nullable<int> x = null;]]></Before>
        <After><![CDATA[int? x = null;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1021</Id>
    <Identifier>ConvertLambdaExpressionBodyToExpressionBody</Identifier>
    <Title>Convert lambda expression body to expression body</Title>
    <MessageFormat>Use expression-bodied lambda</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.Select(f =>
{
    return f.ToString();
});]]></Before>
        <After><![CDATA[var x = items.Select(f => f.ToString());]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1022</Id>
    <Identifier>SimplifyLambdaExpressionParameterList</Identifier>
    <Status>Disabled</Status>
    <Title>Simplify lambda expression parameter list</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
  </Analyzer>
  <Analyzer>
    <Id>RCS1023</Id>
    <Identifier>FormatEmptyBlock</Identifier>
    <Status>Disabled</Status>
    <Title>Format empty block</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo()
{ }]]></Before>
        <After><![CDATA[void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1024</Id>
    <Identifier>FormatAccessorList</Identifier>
    <Status>Disabled</Status>
    <Title>Format accessor list</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo { get { return _foo; } set { _foo = value; } }]]></Before>
        <After><![CDATA[string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1025</Id>
    <Identifier>AddNewLineBeforeEnumMember</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line before enum member</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum Foo { A, B, C, }]]></Before>
        <After><![CDATA[enum Foo
{
    A,
    B,
    C,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1026</Id>
    <Identifier>AddNewLineBeforeStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line before statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo(); Bar();]]></Before>
        <After><![CDATA[Foo();
Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1027</Id>
    <Identifier>AddNewLineBeforeEmbeddedStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line before embedded statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x) Foo();]]></Before>
        <After><![CDATA[if (x)
{
    Foo();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1028</Id>
    <Identifier>AddNewLineAfterSwitchLabel</Identifier>
    <Status>Disabled</Status>
    <Title>Add new line after switch label</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a": return Foo();
    case "b": return Bar();
}]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        return Foo();
    case "b":
        return Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1029</Id>
    <Identifier>FormatBinaryOperatorOnNextLine</Identifier>
    <Status>Disabled</Status>
    <Title>Format binary operator on next line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x &&
    y &&
    z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1030</Id>
    <Identifier>AddEmptyLineAfterEmbeddedStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Add empty line after embedded statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
    Foo();
Bar();]]></Before>
        <After><![CDATA[if (x)
    Foo();

Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1031</Id>
    <Identifier>RemoveUnnecessaryBracesInSwitchSection</Identifier>
    <Title>Remove unnecessary braces in switch section</Title>
    <MessageFormat>Remove unnecessary braces</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a":
        {
            M();
            break;
        }
    case "b":
        break;
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        M();
        break;

    case "b":
        break;
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1032</Id>
    <Identifier>RemoveRedundantParentheses</Identifier>
    <Title>Remove redundant parentheses</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if ((x))
{
    return (y);
}]]></Before>
        <After><![CDATA[if (x)
{
    return y;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1033</Id>
    <Identifier>RemoveRedundantBooleanLiteral</Identifier>
    <Title>Remove redundant boolean literal</Title>
    <MessageFormat>Remove redundant '{0}'</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[if (f == true)
{
}

if (f != false)
{
}]]></Before>
        <After><![CDATA[if (f)
{
}

if (f)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1034</Id>
    <Identifier>RemoveRedundantSealedModifier</Identifier>
    <Title>Remove redundant 'sealed' modifier</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public sealed class Foo
{
    public sealed override string ToString()
    {
        return "";
    }
}]]></Before>
        <After><![CDATA[public override string ToString()
{
    return "";
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1035</Id>
    <Identifier>RemoveRedundantCommaInInitializer</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1260 instead</ObsoleteMessage>
    <Title>Remove redundant comma in initializer</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    var arr = new string[] { "a", "b", "c", };
}]]></Before>
        <After><![CDATA[public void Foo()
{
    var arr = new string[] { "a", "b", "c" };
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1036</Id>
    <Identifier>Obsolete_RemoveUnnecessaryBlankLine</Identifier>
    <Title>Remove unnecessary blank line</Title>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS0063 instead</ObsoleteMessage>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{

    private string _f;


    public bool Bar()
    {

        return false;

    }

}]]></Before>
        <After><![CDATA[public class Foo
{
    private string _f;

    public bool Bar()
    {
        return false;
    }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_closing_brace_and_switch_section" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1037</Id>
    <Identifier>RemoveTrailingWhitespace</Identifier>
    <Title>Remove trailing white-space</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1038</Id>
    <Identifier>RemoveEmptyStatement</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    ;
}]]></Before>
        <After><![CDATA[public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1039</Id>
    <Identifier>RemoveArgumentListFromAttribute</Identifier>
    <Title>Remove argument list from attribute</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[[Obsolete()]
public void Foo()
{
}]]></Before>
        <After><![CDATA[[Obsolete]
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1040</Id>
    <Identifier>RemoveEmptyElseClause</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty 'else' clause</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    Foo();
}
else
{
}]]></Before>
        <After><![CDATA[if (condition)
{
    Foo();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1041</Id>
    <Identifier>RemoveEmptyInitializer</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty initializer</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<object>() { };]]></Before>
        <After><![CDATA[var items = new List<object>();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1042</Id>
    <Identifier>RemoveEnumDefaultUnderlyingType</Identifier>
    <Title>Remove enum default underlying type</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo : int
{
}]]></Before>
        <After><![CDATA[public enum Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1043</Id>
    <Identifier>RemovePartialModifierFromTypeWithSinglePart</Identifier>
    <Title>Remove 'partial' modifier from type with a single part</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public partial class Foo
{
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1044</Id>
    <Identifier>RemoveOriginalExceptionFromThrowStatement</Identifier>
    <Title>Remove original exception from throw statement</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
    throw ex;
}]]></Before>
        <After><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
    throw;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1045</Id>
    <Identifier>RenamePrivateFieldToCamelCaseWithUnderscore</Identifier>
    <Status>Disabled</Status>
    <Title>Rename private field to camel case with underscore</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private string f;]]></Before>
        <After><![CDATA[private string _f;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1046</Id>
    <Identifier>AsynchronousMethodNameShouldEndWithAsync</Identifier>
    <Title>Asynchronous method name should end with 'Async'</Title>
    <MessageFormat>Add suffix 'Async' to asynchronous method name</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public static async Task<bool> Foo()
{
    return await Task.FromResult(false);
}]]></Before>
        <After><![CDATA[public static async Task<bool> FooAsync()
{
    return await Task.FromResult(false);
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1047</Id>
    <Identifier>NonAsynchronousMethodNameShouldNotEndWithAsync</Identifier>
    <Title>Non-asynchronous method name should not end with 'Async'</Title>
    <MessageFormat>Remove suffix 'Async' from non-asynchronous method name</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[public void FooAsync()
{
}]]></Before>
        <After><![CDATA[public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1048</Id>
    <Identifier>UseLambdaExpressionInsteadOfAnonymousMethod</Identifier>
    <Title>Use lambda expression instead of anonymous method</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.Select(delegate (object f)
{
    return f.ToString();
});]]></Before>
        <After><![CDATA[var x = items.Select((object f) =>
{
    return f.ToString();
});]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1049</Id>
    <Identifier>SimplifyBooleanComparison</Identifier>
    <Title>Simplify boolean comparison</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[bool f = false;

// ...

if (f == false)
{
}

if (f != true)
{
}]]></Before>
        <After><![CDATA[if (!f)
{
}

if (!f)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1050</Id>
    <Identifier>IncludeParenthesesWhenCreatingNewObject</Identifier>
    <Title>Include/omit parentheses when creating new object</Title>
    <MessageFormat>{0} parentheses when creating new object</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<string> { "a", "b", "c"  };]]></Before>
        <After><![CDATA[var items = new List<string>() { "a", "b", "c"  };]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="object_creation_parentheses_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1051</Id>
    <Identifier>AddOrRemoveParenthesesFromConditionInConditionalOperator</Identifier>
    <Title>Add/remove parentheses from condition in conditional operator</Title>
    <MessageFormat>{0} parentheses {1} condition</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[x = y != null ? "true" : "false"]]></Before>
        <After><![CDATA[x = (y != null) ? "true" : "false"]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="conditional_operator_condition_parentheses_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1052</Id>
    <Identifier>DeclareEachAttributeSeparately</Identifier>
    <Title>Declare each attribute separately</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Obsolete, Conditional("DEBUG")]
public void Foo()
{
}]]></Before>
        <After><![CDATA[[Obsolete]
[Conditional("DEBUG")]
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1053</Id>
    <Identifier>ReplaceForEachWithFor</Identifier>
    <Status>Disabled</Status>
    <Title>Replace foreach statement with for statement</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
  </Analyzer>
  <Analyzer>
    <Id>RCS1054</Id>
    <Identifier>MergeLocalDeclarationWithReturnStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Merge local declaration with return statement</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
  </Analyzer>
  <Analyzer>
    <Id>RCS1055</Id>
    <Identifier>UnnecessarySemicolonAtEndOfDeclaration</Identifier>
    <Title>Unnecessary semicolon at the end of declaration</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
};]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1056</Id>
    <Identifier>AvoidUsageOfUsingAliasDirective</Identifier>
    <Title>Avoid usage of using alias directive</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using S = System.String;

public class Foo
{
    public void Bar()
    {
        string s = S.Empty;
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    public void Bar()
    {
        string s = System.String.Empty;
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1057</Id>
    <Identifier>AddEmptyLineBetweenDeclarations</Identifier>
    <Status>Disabled</Status>
    <Title>Add empty line between declarations</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
{
    void M1()
    {
    }
    void M2()
    {
    }
    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }
    string P1 { get; set; }
    [Obsolete]
    string P2 { get; set; }
}
enum Bar
{
    A = 0,
    /// <summary>
    /// ...
    /// </summary>
    B = 1,
    [Obsolete]
    C = 2,
}]]></Before>
        <After><![CDATA[class Foo
{
    void M1()
    {
    }

    void M2()
    {
    }

    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }

    string P1 { get; set; }

    [Obsolete]
    string P2 { get; set; }
}

enum Bar
{
    A = 0,

    /// <summary>
    /// ...
    /// </summary>
    B = 1,

    [Obsolete]
    C = 2,
}]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer does not enforce an empty line between two single-line declaration.</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS1058</Id>
    <Identifier>UseCompoundAssignment</Identifier>
    <Title>Use compound assignment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <MinLanguageVersion>8.0 (??= operator)</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[x = x + 2;]]></Before>
        <After><![CDATA[x += 2;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[x ?? (x = M())]]></Before>
        <After><![CDATA[x ??= M()]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/cs-cz/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment</Url>
        <Text>Compound assignment</Text>
      </Link>
      <Link>
        <Url>https://docs.microsoft.com/dotnet/csharp/language-reference/operators/null-coalescing-operator</Url>
        <Text>?? and ??= operators</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1059</Id>
    <Identifier>AvoidLockingOnPubliclyAccessibleInstance</Identifier>
    <Title>Avoid locking on publicly accessible instance</Title>
    <MessageFormat>Lock on private field instead of locking on '{0}'</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    lock (this)
    {
    }
}]]></Before>
        <After><![CDATA[private readonly object _lockObject = new object();

public void Foo()
{
    lock (_lockObject)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1060</Id>
    <Identifier>DeclareEachTypeInSeparateFile</Identifier>
    <Title>Declare each type in separate file</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
}

public class Bar
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1061</Id>
    <Identifier>MergeIfWithNestedIf</Identifier>
    <Title>Merge 'if' with nested 'if'</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    if (condition2)
    {
    }
}]]></Before>
        <After><![CDATA[if (condition && condition2)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1062</Id>
    <Identifier>AvoidInterpolatedStringWithNoInterpolation</Identifier>
    <Status>Disabled</Status>
    <Title>Avoid interpolated string with no interpolation</Title>
    <MessageFormat>Remove '$' from interpolated string with no interpolation</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"";]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1063</Id>
    <Identifier>AvoidUsageOfDoStatementToCreateInfiniteLoop</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1252 instead</ObsoleteMessage>
    <Title>Avoid usage of do statement to create an infinite loop</Title>
    <MessageFormat>Use while statement to create an infinite loop</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    // ...
}
while (true);]]></Before>
        <After><![CDATA[while (true)
{
    // ...
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1064</Id>
    <Identifier>AvoidUsageOfForStatementToCreateInfiniteLoop</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1252 instead</ObsoleteMessage>
    <Title>Avoid usage of for statement to create an infinite loop</Title>
    <MessageFormat>Use while statement to create an infinite loop</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[for (;;)
{
}]]></Before>
        <After><![CDATA[while (true)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1065</Id>
    <Identifier>AvoidUsageOfWhileStatementToCreateInfiniteLoop</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1252 instead</ObsoleteMessage>
    <Title>Avoid usage of while statement to create an infinite loop</Title>
    <MessageFormat>Use for statement to create an infinite loop</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[while (true)
{
}]]></Before>
        <After><![CDATA[for (;;)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1066</Id>
    <Identifier>RemoveEmptyFinallyClause</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty 'finally' clause</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
finally
{
}]]></Before>
        <After><![CDATA[Foo();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
}
finally
{
}]]></Before>
        <After><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1067</Id>
    <Identifier>RemoveArgumentListFromObjectCreation2</Identifier>
    <Status>Disabled</Status>
    <Title>Remove argument list from object creation expression</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<string>() { "a", "b", "c" };]]></Before>
        <After><![CDATA[var items = new List<string> { "a", "b", "c" };]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1068</Id>
    <Identifier>SimplifyLogicalNegation</Identifier>
    <Title>Simplify logical negation</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool f = !true;]]></Before>
        <After><![CDATA[bool f = false;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool f = !!f2;]]></Before>
        <After><![CDATA[bool f = f2;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool f = !items.Any(s => !string.IsNullOrEmpty(s));]]></Before>
        <After><![CDATA[bool f = items.All(s => string.IsNullOrEmpty(s));]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1069</Id>
    <Identifier>RemoveUnnecessaryCaseLabel</Identifier>
    <Title>Remove unnecessary case label</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        return true;
    case "b":
    default:
        return false;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
        return true;
    default:
        return false;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1070</Id>
    <Identifier>RemoveRedundantDefaultSwitchSection</Identifier>
    <Title>Remove redundant default switch section</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        return true;
    case "b":
        return false;
    default:
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
        return true;
    case "b":
        return false;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1071</Id>
    <Identifier>RemoveRedundantBaseConstructorCall</Identifier>
    <Title>Remove redundant base constructor call</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public Foo() : base()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    public Foo()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1072</Id>
    <Identifier>RemoveEmptyNamespaceDeclaration</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty namespace declaration</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[namespace Foo
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1073</Id>
    <Identifier>ConvertIfToReturnStatement</Identifier>
    <Title>Convert 'if' to 'return' statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    return true;
}
else
{
    return false;
}]]></Before>
        <After><![CDATA[return x;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x != null)
{
    return x;
}
else
{
    return null;
}]]></Before>
        <After><![CDATA[return x;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1074</Id>
    <Identifier>RemoveRedundantConstructor</Identifier>
    <Title>Remove redundant constructor</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1075</Id>
    <Identifier>AvoidEmptyCatchClauseThatCatchesSystemException</Identifier>
    <Title>Avoid empty catch clause that catches System.Exception</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1076</Id>
    <Identifier>FormatDeclarationBraces</Identifier>
    <Status>Disabled</Status>
    <Title>Format declaration braces</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{ }]]></Before>
        <After><![CDATA[interface IFoo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1077</Id>
    <Identifier>OptimizeLinqMethodCall</Identifier>
    <Title>Optimize LINQ method call</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool any = items.Where(predicate).Any();]]></Before>
        <After><![CDATA[bool any = items.Any(predicate);]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[int max = items.Select(selector).Max();]]></Before>
        <After><![CDATA[int max = items.Max(selector);]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[IEnumerable<Foo> x = items.Where(f => f is Foo).Cast<Foo>();]]></Before>
        <After><![CDATA[IEnumerable<Foo> x = items.OfType<Foo>();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = items.Where((f) => Foo1(f)).Any(f => Foo2(f));]]></Before>
        <After><![CDATA[bool x = items.Any((f) => Foo1(f) && Foo2(f));]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[IEnumerable<object> x = items.Select(f => (object)f);]]></Before>
        <After><![CDATA[IEnumerable<object> x = items.Cast<object>();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = items.FirstOrDefault((f) => Foo(f)) != null;]]></Before>
        <After><![CDATA[bool x = items.Any((f) => Foo(f));]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = items.FirstOrDefault() != null;]]></Before>
        <After><![CDATA[bool x = items.Any();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (enumerable.Count() != 0)
{
}]]></Before>
        <After><![CDATA[if (enumerable.Any())
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (list.Count() == 1)
{
}]]></Before>
        <After><![CDATA[if (list.Count == 1)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[var stack = new Stack<object>();
// ...
object x = stack.First();]]></Before>
        <After><![CDATA[var stack = new Stack<object>();
// ...
object x = stack.Peek();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[var queue = new Queue<object>();
// ...
object x = queue.First();]]></Before>
        <After><![CDATA[var queue = new Queue<object>();
// ...
object x = queue.Peek();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[enumerable.Any() ? enumerable.First() : default]]></Before>
        <After><![CDATA[enumerable.FirstOrDefault()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[enumerable.OrderBy(f => f).Reverse()]]></Before>
        <After><![CDATA[enumerable.OrderByDescending()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[enumerable.SelectMany(f => f.Items).Count()]]></Before>
        <After><![CDATA[enumerable.Sum(f => f.Items.Count)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[listOfT.Select(f => M(f)).ToList()]]></Before>
        <After><![CDATA[listOfT.ConvertAll(f => M(f))]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1078</Id>
    <Identifier>UseEmptyStringLiteralOrStringEmpty</Identifier>
    <Title>Use "" or 'string.Empty'</Title>
    <MessageFormat>Use {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = string.Empty;]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="empty_string_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1079</Id>
    <Identifier>ThrowingOfNewNotImplementedException</Identifier>
    <Title>Throwing of new NotImplementedException</Title>
    <MessageFormat>Implement the functionality instead of throwing new NotImplementedException</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    throw new NotImplementedException();
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1080</Id>
    <Identifier>UseCountOrLengthPropertyInsteadOfAnyMethod</Identifier>
    <Title>Use 'Count/Length' property instead of 'Any' method</Title>
    <MessageFormat>Use '{0}' property instead of 'Any' method</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (list.Any())
{
}]]></Before>
        <After><![CDATA[if (list.Count > 0)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1081</Id>
    <Identifier>SplitVariableDeclaration</Identifier>
    <Title>Split variable declaration</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private string s, s2;]]></Before>
        <After><![CDATA[private string s;
private string s2;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1082</Id>
    <Identifier>UseCountOrLengthPropertyInsteadOfCountMethod</Identifier>
    <Status>Disabled</Status>
    <Title>Use 'Count/Length' property instead of 'Count' method</Title>
    <MessageFormat>Use '{0}' property instead of 'Count' method</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (list.Count() == 1)
{
}]]></Before>
        <After><![CDATA[if (list.Count == 1)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1083</Id>
    <Identifier>CallAnyInsteadOfCount</Identifier>
    <Status>Disabled</Status>
    <Title>Call 'Enumerable.Any' instead of 'Enumerable.Count'</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (enumerable.Count() == 0)
{
}]]></Before>
        <After><![CDATA[if (!enumerable.Any())
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1084</Id>
    <Identifier>UseCoalesceExpressionInsteadOfConditionalExpression</Identifier>
    <Title>Use coalesce expression instead of conditional expression</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string x = (s != null) ? s : "";]]></Before>
        <After><![CDATA[string x = s ?? "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1085</Id>
    <Identifier>UseAutoProperty</Identifier>
    <Title>Use auto-implemented property</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[private string _foo;

public string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></Before>
        <After><![CDATA[public string Foo { get; set; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1086</Id>
    <Identifier>UseLinefeedAsNewLine</Identifier>
    <Status>Disabled</Status>
    <Title>Use linefeed as new line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1087</Id>
    <Identifier>UseCarriageReturnAndLinefeedAsNewLine</Identifier>
    <Status>Disabled</Status>
    <Title>Use carriage return + linefeed as new line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1088</Id>
    <Identifier>UseSpacesInsteadOfTab</Identifier>
    <Status>Disabled</Status>
    <Title>Use space(s) instead of tab</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1089</Id>
    <Identifier>UseUnaryOperatorInsteadOfAssignment</Identifier>
    <Title>Use --/++ operator instead of assignment</Title>
    <MessageFormat>Use {0} operator instead of assignment</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[i = i + 1;]]></Before>
        <After><![CDATA[i++;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[M(i + 1);]]></Before>
        <After><![CDATA[M(++i);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1090</Id>
    <Identifier>ConfigureAwait</Identifier>
    <Title>Add/remove 'ConfigureAwait(false)' call</Title>
    <MessageFormat>{0} 'ConfigureAwait(false)' call</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public async Task FooAsync()
{
    await GetValueAsync();
}]]></Before>
        <After><![CDATA[public async Task FooAsync()
{
    await GetValueAsync().ConfigureAwait(false);
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="configure_await" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1091</Id>
    <Identifier>RemoveEmptyRegion</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty region</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[#region Region
            
#endregion]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1092</Id>
    <Identifier>AddEmptyLineBeforeWhileInDoStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Add empty line before 'while' keyword in 'do' statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
} while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();

} while (x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1093</Id>
    <Identifier>FileContainsNoCode</Identifier>
    <Title>File contains no code</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1094</Id>
    <Identifier>DeclareUsingDirectiveOnTopLevel</Identifier>
    <Title>Declare using directive on top level</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[namespace Foo
{
    using System;
}]]></Before>
        <After><![CDATA[using System;

namespace Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1095</Id>
    <Identifier>UseCSharp6DictionaryInitializer</Identifier>
    <Status>Disabled</Status>
    <Title>Use C# 6.0 dictionary initializer</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1096</Id>
    <Identifier>UseHasFlagMethodOrBitwiseOperator</Identifier>
    <Title>Use 'HasFlag' method or bitwise operator</Title>
    <MessageFormat>Use {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[options.HasFlag(RegexOptions.IgnoreCase)]]></Before>
        <After><![CDATA[(options & RegexOptions.IgnoreCase) != 0]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="enum_has_flag_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1097</Id>
    <Identifier>RemoveRedundantToStringCall</Identifier>
    <Title>Remove redundant 'ToString' call</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string x = s.ToString();]]></Before>
        <After><![CDATA[string x = s;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string x = $"{s.ToString()}";]]></Before>
        <After><![CDATA[string x = $"{s}";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1098</Id>
    <Identifier>ConstantValuesShouldBePlacedOnRightSideOfComparisons</Identifier>
    <Title>Constant values should be placed on right side of comparisons</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (null == x)
{ 
}]]></Before>
        <After><![CDATA[if (x == null)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1099</Id>
    <Identifier>DefaultLabelShouldBeLastLabelInSwitchSection</Identifier>
    <Title>Default label should be the last label in a switch section</Title>
    <MessageFormat>Move default label to the last position in a switch section</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    default:
    case "a":
    case "b":
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "b":
    case "a":
    default:
        break;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1100</Id>
    <Identifier>FormatDocumentationSummaryOnSingleLine</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1253 instead</ObsoleteMessage>
    <Title>Format documentation summary on a single line</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
public void Foo()
{
}]]></Before>
        <After><![CDATA[/// <summary>...</summary>
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1101</Id>
    <Identifier>FormatDocumentationSummaryOnMultipleLines</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1253 instead</ObsoleteMessage>
    <Title>Format documentation summary on multiple lines</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>...</summary>
public void Foo()
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1102</Id>
    <Identifier>MakeClassStatic</Identifier>
    <Title>Make class static</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private static string _f;

    public static void Bar()
    {
    }
}]]></Before>
        <After><![CDATA[public static class Foo
{
    private static string _f;

    public static void Bar()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1103</Id>
    <Identifier>ConvertIfToAssignment</Identifier>
    <Title>Convert 'if' to assignment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    f = true;
}
else
{
    f = false;
}]]></Before>
        <After><![CDATA[f = condition;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x != null)
{
    y = x;
}
else
{
    y = null;
}]]></Before>
        <After><![CDATA[y = x;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1104</Id>
    <Identifier>SimplifyConditionalExpression</Identifier>
    <Title>Simplify conditional expression</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool x = y ? true : false;]]></Before>
        <After><![CDATA[bool x = y;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? false : true;]]></Before>
        <After><![CDATA[bool x = !y;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? z : false;]]></Before>
        <After><![CDATA[bool x = y && z;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? true : z;]]></Before>
        <After><![CDATA[bool x = y || z;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1105</Id>
    <Identifier>UnnecessaryInterpolation</Identifier>
    <Title>Unnecessary interpolation</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"a{"b"}c";]]></Before>
        <After><![CDATA[string s = $"abc";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1106</Id>
    <Identifier>RemoveEmptyDestructor</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1259 instead</ObsoleteMessage>
    <Title>Remove empty destructor</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    ~Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1107</Id>
    <Identifier>RemoveRedundantStringToCharArrayCall</Identifier>
    <Title>Remove redundant 'ToCharArray' call</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[foreach (char ch in s.ToCharArray())
{
}]]></Before>
        <After><![CDATA[foreach (char ch in s)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1108</Id>
    <Identifier>AddStaticModifierToAllPartialClassDeclarations</Identifier>
    <Title>Add 'static' modifier to all partial class declarations</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public static partial class Foo
{
}

public partial class Foo
{
}]]></Before>
        <After><![CDATA[public static partial class Foo
{
}

public static partial class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1109</Id>
    <Identifier>CallCastInsteadOfSelect</Identifier>
    <Status>Disabled</Status>
    <Title>Call 'Enumerable.Cast' instead of 'Enumerable.Select'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> x = items.Select(f => (object)f);]]></Before>
        <After><![CDATA[IEnumerable<object> x = items.Cast<object>();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1110</Id>
    <Identifier>DeclareTypeInsideNamespace</Identifier>
    <Title>Declare type inside namespace</Title>
    <MessageFormat>Declare '{0}' inside namespace</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
}]]></Before>
        <After><![CDATA[namespace Namespace
{
    public class Foo
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1111</Id>
    <Identifier>AddBracesToSwitchSectionWithMultipleStatements</Identifier>
    <Title>Add braces to switch section with multiple statements</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        Foo();
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
        {
            Foo();
            break;
        }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1112</Id>
    <Identifier>CombineEnumerableWhereMethodChain</Identifier>
    <Title>Combine 'Enumerable.Where' method chain</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<string> x = items.Where(f => Foo(f)).Where(f => Bar(f));]]></Before>
        <After><![CDATA[IEnumerable<string> x = items.Where(f => Foo(f) && Bar(f));]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1113</Id>
    <Identifier>UseStringIsNullOrEmptyMethod</Identifier>
    <Title>Use 'string.IsNullOrEmpty' method</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s == null || s.Length == 0)
{
}]]></Before>
        <After><![CDATA[if (string.IsNullOrEmpty(s))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1114</Id>
    <Identifier>RemoveRedundantDelegateCreation</Identifier>
    <Title>Remove redundant delegate creation</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[Changed += new EventHandler(OnChanged);]]></Before>
        <After><![CDATA[Changed += OnChanged;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1115</Id>
    <Identifier>ReplaceReturnStatementWithExpressionStatement</Identifier>
    <Status>Disabled</Status>
    <Title>Replace yield/return statement with expression statement</Title>
    <MessageFormat>Replace {0} statement with expression statement</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer>
    <Id>RCS1116</Id>
    <Identifier>AddBreakStatementToSwitchSection</Identifier>
    <Status>Disabled</Status>
    <Title>Add break statement to switch section</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1117</Id>
    <Identifier>AddReturnStatementThatReturnsDefaultValue</Identifier>
    <Status>Disabled</Status>
    <Title>Add return statement that returns default value</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1118</Id>
    <Identifier>MarkLocalVariableAsConst</Identifier>
    <Title>Mark local variable as const</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = "a";
string s2 = s + "b";]]></Before>
        <After><![CDATA[const string s = "a";
string s2 = s + "b";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1119</Id>
    <Identifier>CallFindInsteadOfFirstOrDefault</Identifier>
    <Status>Disabled</Status>
    <Title>Call 'Find' instead of 'FirstOrDefault'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = list.FirstOrDefault(f => f.StartsWith("a"));]]></Before>
        <After><![CDATA[string s = list.Find(f => f.StartsWith("a"));]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1120</Id>
    <Identifier>UseElementAccessInsteadOfElementAt</Identifier>
    <Status>Disabled</Status>
    <Title>Use [] instead of calling 'ElementAt'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = list.ElementAt(1);]]></Before>
        <After><![CDATA[var x = list[1];]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1121</Id>
    <Identifier>UseElementAccessInsteadOfFirst</Identifier>
    <Status>Disabled</Status>
    <Title>Use [] instead of calling 'First'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = list.First();]]></Before>
        <After><![CDATA[var x = list[0];]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1122</Id>
    <Identifier>AddMissingSemicolon</Identifier>
    <Status>Disabled</Status>
    <Title>Add missing semicolon</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1123</Id>
    <Identifier>AddParenthesesWhenNecessary</Identifier>
    <Title>Add parentheses when necessary</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x || y && z)
{
}]]></Before>
        <After><![CDATA[if (x || (y && z))
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[x?.y!.z]]></Before>
        <After><![CDATA[(x?.y)!.z]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1124</Id>
    <Identifier>InlineLocalVariable</Identifier>
    <Title>Inline local variable</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> items = GetValues();
foreach (object item in items)
{
}]]></Before>
        <After><![CDATA[foreach (object item in GetValues())
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1125</Id>
    <Identifier>MarkMemberAsStatic</Identifier>
    <Status>Disabled</Status>
    <Title>Mark member as static</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1126</Id>
    <Identifier>AddBracesToIfElse</Identifier>
    <Title>Add braces to if-else</Title>
    <MessageFormat>Add braces to {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    Foo();
else
    Bar();]]></Before>
        <After><![CDATA[if (condition)
{
    Foo();
}
else
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1127</Id>
    <Identifier>MergeLocalDeclarationWithAssignment</Identifier>
    <Status>Disabled</Status>
    <Title>Merge local declaration with assignment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[string s;
s = "";]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1128</Id>
    <Identifier>UseCoalesceExpression</Identifier>
    <Title>Use coalesce expression</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = GetValue();

if (s == null)
{
    s = "";
}]]></Before>
        <After><![CDATA[string s = GetValue() ?? "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1129</Id>
    <Identifier>RemoveRedundantFieldInitialization</Identifier>
    <Title>Remove redundant field initialization</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[private bool _f = false;]]></Before>
        <After><![CDATA[private bool _f;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1130</Id>
    <Identifier>BitwiseOperationOnEnumWithoutFlagsAttribute</Identifier>
    <Title>Bitwise operation on enum without Flags attribute</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[DayOfWeek x = dayOfWeek | DayOfWeek.Tuesday;]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1131</Id>
    <Identifier>ReplaceReturnWithYieldReturn</Identifier>
    <Status>Disabled</Status>
    <Title>Replace return with yield return</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1132</Id>
    <Identifier>RemoveRedundantOverridingMember</Identifier>
    <Title>Remove redundant overriding member</Title>
    <MessageFormat>Remove redundant overriding {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public override string ToString()
    {
        return base.ToString();
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1133</Id>
    <Identifier>RemoveRedundantDisposeOrCloseCall</Identifier>
    <Title>Remove redundant Dispose/Close call</Title>
    <MessageFormat>Remove redundant '{0}' call</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[using (streamReader)
{
    // ...

    streamReader.Dispose();
}]]></Before>
        <After><![CDATA[using (streamReader)
{
    // ...
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1134</Id>
    <Identifier>RemoveRedundantStatement</Identifier>
    <Title>Remove redundant statement</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    // ...

    return false;
}

return false;]]></Before>
        <After><![CDATA[if (x)
{
    // ...
}

return false;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    // ...

    return;
}]]></Before>
        <After><![CDATA[public void Foo()
{
    // ...
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[foreach (object item in items)
{
    /// ...

    continue;
}]]></Before>
        <After><![CDATA[]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1135</Id>
    <Identifier>DeclareEnumMemberWithZeroValue</Identifier>
    <Title>Declare enum member with zero value (when enum has FlagsAttribute)</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
public enum Foo
{
    A = 1,
    B = 2
}]]></Before>
        <After><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1136</Id>
    <Identifier>MergeSwitchSectionsWithEquivalentContent</Identifier>
    <Title>Merge switch sections with equivalent content</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        break;
    case "b":
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
    case "b":
        break;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1137</Id>
    <Identifier>AddDocumentationComment</Identifier>
    <Status>Disabled</Status>
    <Title>Add documentation comment to publicly visible type or member</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1138</Id>
    <Identifier>AddSummaryToDocumentationComment</Identifier>
    <Title>Add summary to documentation comment</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// 
/// </summary>
public void Foo()
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1139</Id>
    <Identifier>AddSummaryElementToDocumentationComment</Identifier>
    <Title>Add summary element to documentation comment</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <param name="parameter"></param>
public void Foo(object parameter)
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// 
/// </summary>
/// <param name="parameter"></param>
public void Foo(object parameter)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1140</Id>
    <Identifier>AddExceptionToDocumentationComment</Identifier>
    <Title>Add exception to documentation comment</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
/// <param name="parameter"></param>
public void Foo(object parameter)
{
    if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
/// <param name="parameter"></param>
/// <exception cref="ArgumentNullException"><paramref name="parameter"/> is <c>null</c>.</exception>
public void Foo(object parameter)
{
    if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1141</Id>
    <Identifier>AddParamElementToDocumentationComment</Identifier>
    <Title>Add 'param' element to documentation comment</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
public void Foo(object parameter)
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
/// <param name="parameter"></param>
public void Foo(object parameter)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1142</Id>
    <Identifier>AddTypeParamElementToDocumentationComment</Identifier>
    <Title>Add 'typeparam' element to documentation comment</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
/// <typeparam name="T1"></typeparam>
public class Foo<T1, T2>
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
/// <typeparam name="T1"></typeparam>
/// <typeparam name="T2"></typeparam>
public class Foo<T1, T2>
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1143</Id>
    <Identifier>SimplifyCoalesceExpression</Identifier>
    <Title>Simplify coalesce expression</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = default(string) ?? "";]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1144</Id>
    <Identifier>MarkContainingClassAsAbstract</Identifier>
    <Status>Disabled</Status>
    <Title>Mark containing class as abstract</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1145</Id>
    <Identifier>RemoveRedundantAsOperator</Identifier>
    <Title>Remove redundant 'as' operator</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = null;

string s2 = s as string;]]></Before>
        <After><![CDATA[string s2 = s;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1146</Id>
    <Identifier>UseConditionalAccess</Identifier>
    <Title>Use conditional access</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s != null && s.StartsWith("a"))
{
}]]></Before>
        <After><![CDATA[if (s?.StartsWith("a") == true)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (dic != null && dic[0].StartsWith("a"))
{
}]]></Before>
        <After><![CDATA[if (dic?[0].StartsWith("a") == true)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x != null)
    x.Foo();]]></Before>
        <After><![CDATA[x?.Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1147</Id>
    <Identifier>RemoveInapplicableModifier</Identifier>
    <Status>Disabled</Status>
    <Title>Remove inapplicable modifier</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer>
    <Id>RCS1148</Id>
    <Identifier>RemoveUnreachableCode</Identifier>
    <Status>Disabled</Status>
    <Title>Remove unreachable code</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer>
    <Id>RCS1149</Id>
    <Identifier>RemoveImplementationFromAbstractMember</Identifier>
    <Status>Disabled</Status>
    <Title>Remove implementation from abstract member</Title>
    <MessageFormat>Remove implementation from {0}</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer>
    <Id>RCS1150</Id>
    <Identifier>CallStringConcatInsteadOfStringJoin</Identifier>
    <Status>Disabled</Status>
    <Title>Call string.Concat instead of string.Join</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = string.Join("", "a", "b", "c");]]></Before>
        <After><![CDATA[string s = string.Concat("a", "b", "c");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1151</Id>
    <Identifier>RemoveRedundantCast</Identifier>
    <Title>Remove redundant cast</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var b = new Base();

((Foo)b).Bar();]]></Before>
        <After><![CDATA[b.Bar();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[IEnumerable<string> x = EnumerateStrings().Cast<string>();]]></Before>
        <After><![CDATA[IEnumerable<string> x = EnumerateStrings();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1152</Id>
    <Identifier>MemberTypeMustMatchOverriddenMemberType</Identifier>
    <Status>Disabled</Status>
    <Title>Member type must match overridden member type</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1153</Id>
    <Identifier>AddEmptyLineAfterClosingBrace</Identifier>
    <Status>Disabled</Status>
    <Title>Add empty line after closing brace</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
}
Foo();]]></Before>
        <After><![CDATA[if (x)
{
}

Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1154</Id>
    <Identifier>SortEnumMembers</Identifier>
    <Title>Sort enum members</Title>
    <MessageFormat>Sort '{0}' members</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo
{
    D = 4,
    B = 2,
    A = 1,
    C = 3
}]]></Before>
        <After><![CDATA[public enum Foo
{
    A = 1,
    B = 2,
    C = 3,
    D = 4
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1155</Id>
    <Identifier>UseStringComparison</Identifier>
    <Title>Use StringComparison when comparing strings</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x.ToLower() == y.ToLower())
{
}]]></Before>
        <After><![CDATA[if (string.Equals(x, y, StringComparison.OrdinalIgnoreCase))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1156</Id>
    <Identifier>UseStringLengthInsteadOfComparisonWithEmptyString</Identifier>
    <Title>Use string.Length instead of comparison with empty string</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s == "")
{
}]]></Before>
        <After><![CDATA[if (s?.Length == 0)
{
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1820</Url>
        <Text>CA1820: Test for empty strings using string length</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1157</Id>
    <Identifier>CompositeEnumValueContainsUndefinedFlag</Identifier>
    <Title>Composite enum value contains undefined flag</Title>
    <MessageFormat>Composite enum value contains undefined flag {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2,
    C = 4,
    D = 8,
    X = 17
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1158</Id>
    <Identifier>StaticMemberInGenericTypeShouldUseTypeParameter</Identifier>
    <Title>Static member in generic type should use a type parameter</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo<T>
{
    public static void Bar()
    {
    }
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1159</Id>
    <Identifier>UseGenericEventHandler</Identifier>
    <Title>Use EventHandler&lt;T&gt;</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public event FooEventHandler EventName;
}

public delegate void FooEventHandler(object sender, FooEventArgs args);]]></Before>
        <After><![CDATA[public class Foo
{
    public event EventHandler<FooEventArgs> EventName;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1160</Id>
    <Identifier>AbstractTypeShouldNotHavePublicConstructors</Identifier>
    <Title>Abstract type should not have public constructors</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public abstract class Foo
{
    public Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public abstract class Foo
{
    protected Foo()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1161</Id>
    <Identifier>EnumShouldDeclareExplicitValues</Identifier>
    <Title>Enum should declare explicit values</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo
{
    A,
    B,
    C,
}]]></Before>
        <After><![CDATA[public enum Foo
{
    A = 0,
    B = 1,
    C = 2,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1162</Id>
    <Identifier>AvoidChainOfAssignments</Identifier>
    <Title>Avoid chain of assignments</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[x = y = z;]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1163</Id>
    <Identifier>UnusedParameter</Identifier>
    <Title>Unused parameter</Title>
    <MessageFormat>Unused parameter '{0}'</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public bool Bar(object parameter)
{
    return false;
}]]></Before>
      </Sample>
    </Samples>
    <Remarks>This analyzer does not provide a code fix. Use built-in "Change signature.." dialog to remove a parameter.

Unused parameter is not reported when its name consists of underscore(s).</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS1164</Id>
    <Identifier>UnusedTypeParameter</Identifier>
    <Title>Unused type parameter</Title>
    <MessageFormat>Unused type parameter '{0}'</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public bool Bar<T>()
{
    return false
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1165</Id>
    <Identifier>UnconstrainedTypeParameterCheckedForNull</Identifier>
    <Title>Unconstrained type parameter checked for null</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo<T1>() where T1 : new()
{
    var x = default(T1);

    if (x == null)
    {
    }
}]]></Before>
        <After><![CDATA[if (EqualityComparer<T1>.Default.Equals(x, default(T1)))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1166</Id>
    <Identifier>ValueTypeObjectIsNeverEqualToNull</Identifier>
    <Title>Value type object is never equal to null</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[int x = 0;
IntPtr y = IntPtr.Zero

// ...

if (x == null)
{
}

if (y == null)
{
}]]></Before>
        <After><![CDATA[if (x == 0)
{
}

if (y == default)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1167</Id>
    <Identifier>OverridingMemberCannotChangeAccessModifiers</Identifier>
    <Status>Disabled</Status>
    <Title>Overriding member cannot change access modifiers</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer>
    <Id>RCS1168</Id>
    <Identifier>ParameterNameDiffersFromBase</Identifier>
    <Title>Parameter name differs from base name</Title>
    <MessageFormat>Parameter name '{0}' differs from base name '{1}'</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{
    string Bar(object parameter);
}

abstract class Foo : IFoo
{
    public abstract string Bar(object value);
}]]></Before>
        <After><![CDATA[interface IFoo
{
    string Bar(object parameter);
}

abstract class Foo : IFoo
{
    public abstract string Bar(object parameter)
};]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1169</Id>
    <Identifier>MakeFieldReadOnly</Identifier>
    <Title>Make field read-only</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="unity_code_analysis.enabled" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private int _f;

    public Foo()
    {
        _f = 0;
    }
}]]></Before>
        <After><![CDATA[private readonly int _f;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1170</Id>
    <Identifier>UseReadOnlyAutoProperty</Identifier>
    <Title>Use read-only auto-implemented property</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[public object Foo { get; private set; }]]></Before>
        <After><![CDATA[public object Foo { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1171</Id>
    <Identifier>SimplifyLazyInitialization</Identifier>
    <Title>Simplify lazy initialization</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public object Foo()
{
    if (_foo == null)
    {
        _foo = Initialize();
    }

    return _foo;
}]]></Before>
        <After><![CDATA[public object Foo()
{
    return _foo ?? (_foo = Initialize());
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1172</Id>
    <Identifier>UseIsOperatorInsteadOfAsOperator</Identifier>
    <Title>Use 'is' operator instead of 'as' operator</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x as string != null)
{
}]]></Before>
        <After><![CDATA[if (x is string)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1173</Id>
    <Identifier>UseCoalesceExpressionInsteadOfIf</Identifier>
    <Title>Use coalesce expression instead of 'if'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x != null)
{
    z = x;
}
else
{
    z = y;
}]]></Before>
        <After><![CDATA[z = x ?? y;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1174</Id>
    <Identifier>RemoveRedundantAsyncAwait</Identifier>
    <Title>Remove redundant async/await</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[public static async Task<object> FooAsync()
{
    return await GetAsync().ConfigureAwait(false);
}]]></Before>
        <After><![CDATA[public static Task<object> FooAsync()
{
    return GetAsync();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1175</Id>
    <Identifier>UnusedThisParameter</Identifier>
    <Title>Unused 'this' parameter</Title>
    <MessageFormat>Unused 'this' parameter '{0}'</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public static bool Bar(this Foo foo, object parameter)
{
    return parameter != null;
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1176</Id>
    <Identifier>UseVarInsteadOfExplicitTypeWhenTypeIsNotObvious</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1264 instead</ObsoleteMessage>
    <Title>Use 'var' instead of explicit type (when the type is not obvious)</Title>
    <MessageFormat>Use 'var' instead of explicit type</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = GetValue();]]></Before>
        <After><![CDATA[var s = GetValue();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1177</Id>
    <Identifier>UseVarInsteadOfExplicitTypeInForEach</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1264 instead</ObsoleteMessage>
    <Title>Use 'var' instead of explicit type (in foreach)</Title>
    <MessageFormat>Use 'var' instead of explicit type</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[foreach (string item in items)
{
}]]></Before>
        <After><![CDATA[foreach (var item in items)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1178</Id>
    <Identifier>CallDebugFailInsteadOfDebugAssert</Identifier>
    <Status>Disabled</Status>
    <Title>Call Debug.Fail instead of Debug.Assert</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Debug.Assert(false, "message");]]></Before>
        <After><![CDATA[Debug.Fail("message");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1179</Id>
    <Identifier>UnnecessaryAssignment</Identifier>
    <Title>Unnecessary assignment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    x = 1;
}
else
{
    x = 2;
}

return x;]]></Before>
        <After><![CDATA[if (condition)
{
    return 1;
}
else
{
    return 2;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1180</Id>
    <Identifier>InlineLazyInitialization</Identifier>
    <Title>Inline lazy initialization</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[List<object> items = null;

// ...

if (items == null)
{
    items = new List<object>();
}

items.Add(x);]]></Before>
        <After><![CDATA[(items ?? (items = new List<object>())).Add(x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1181</Id>
    <Identifier>ConvertCommentToDocumentationComment</Identifier>
    <Title>Convert comment to documentation comment</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Represents foo.
public class Foo
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// Represents foo.
/// </summary>
public class Foo
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[public string Value { get; } // Gets a value.]]></Before>
        <After><![CDATA[/// <summary>
/// Gets a value.
/// </summary>
public string Value { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1182</Id>
    <Identifier>RemoveRedundantBaseInterface</Identifier>
    <Title>Remove redundant base interface</Title>
    <MessageFormat>Interface '{0}' is already implemented by '{1}'</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo<T> : List<T>, IEnumerable<T>
{
}]]></Before>
        <After><![CDATA[public class Foo<T> : List<T>
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1183</Id>
    <Identifier>FormatInitializerWithSingleExpressionOnSingleLine</Identifier>
    <Status>Disabled</Status>
    <Title>Format initializer with single expression on single line</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var dic = new Dictionary<int, string>()
{
    { 0, "0" }
};]]></Before>
        <After><![CDATA[var dic = new Dictionary<int, string>() { { 0, "0" } };]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1184</Id>
    <Identifier>FormatConditionalExpression</Identifier>
    <Status>Disabled</Status>
    <Title>Format conditional expression (format ? and : on next line)</Title>
    <MessageFormat>Format conditional expression</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = (x) ?
Foo() :
Bar();]]></Before>
        <After><![CDATA[var y = (x)
? Foo()
: Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1185</Id>
    <Identifier>FormatSingleLineBlock</Identifier>
    <Status>Disabled</Status>
    <Title>Format single-line block</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo() { Bar(); }]]></Before>
        <After><![CDATA[void Foo()
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1186</Id>
    <Identifier>UseRegexInstanceInsteadOfStaticMethod</Identifier>
    <Title>Use Regex instance instead of static method</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private void Bar()
{
    bool isMatch = Regex.IsMatch("abc", @"\w");
}]]></Before>
        <After><![CDATA[private readonly Regex _regex = new Regex(@"\w");

private void Bar()
{
    bool isMatch = _regex.IsMatch("abc");
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1187</Id>
    <Identifier>UseConstantInsteadOfField</Identifier>
    <Title>Use constant instead of field</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private static readonly int _foo = 0;]]></Before>
        <After><![CDATA[private const int _foo = 0;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1188</Id>
    <Identifier>RemoveRedundantAutoPropertyInitialization</Identifier>
    <Title>Remove redundant auto-property initialization</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public string Foo { get; set; } = null;]]></Before>
        <After><![CDATA[public string Foo { get; set; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1189</Id>
    <Identifier>AddOrRemoveRegionName</Identifier>
    <Title>Add or remove region name</Title>
    <MessageFormat>{0} region name {1} #endregion</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[#region Methods
public static void Foo()
{
}
#endregion]]></Before>
        <After><![CDATA[#region Methods
public static void Foo()
{
}
#endregion Methods]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1190</Id>
    <Identifier>JoinStringExpressions</Identifier>
    <Title>Join string expressions</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = "a" + "b";]]></Before>
        <After><![CDATA[string s = "ab";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1191</Id>
    <Identifier>DeclareEnumValueAsCombinationOfNames</Identifier>
    <Title>Declare enum value as combination of names</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2,
    C = 4,
    ABC = 7
}]]></Before>
        <After><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2,
    C = 4,
    ABC = A | B | C
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1192</Id>
    <Identifier>UnnecessaryUsageOfVerbatimStringLiteral</Identifier>
    <Title>Unnecessary usage of verbatim string literal</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = @"textWithoutEscapeSequence";]]></Before>
        <After><![CDATA[string s = "textWithoutEscapeSequence";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1193</Id>
    <Identifier>OverridingMemberShouldNotChangeParamsModifier</Identifier>
    <Title>Overriding member should not change 'params' modifier</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Base
{
    public virtual void Foo(params object[] values)
    {
    }
}

public class Derived : Base
{
    public override void Foo(object[] values)
    {
    }
}]]></Before>
        <After><![CDATA[public class Derived : Base
{
    public override void Foo(params object[] values)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1194</Id>
    <Identifier>ImplementExceptionConstructors</Identifier>
    <Title>Implement exception constructors</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class FooException : Exception
{
}]]></Before>
        <After><![CDATA[public class FooException : Exception
{
    public FooException() : base()
    {
    }

    public FooException(string message) : base(message)
    {
    }

    public FooException(string message, Exception innerException) : base(message, innerException)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1195</Id>
    <Identifier>UseExclusiveOrOperator</Identifier>
    <Title>Use ^ operator</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if ((x && !y) || (!x && y))
{
}]]></Before>
        <After><![CDATA[if (x ^ y)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1196</Id>
    <Identifier>CallExtensionMethodAsInstanceMethod</Identifier>
    <Title>Call extension method as instance method</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = Enumerable.Select(items, f => f.ToString())]]></Before>
        <After><![CDATA[var x = items.Select(f => f.ToString());]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1197</Id>
    <Identifier>OptimizeStringBuilderAppendCall</Identifier>
    <Title>Optimize StringBuilder.Append/AppendLine call</Title>
    <MessageFormat>Optimize StringBuilder.{0} call</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[sb.Append(s + "x");]]></Before>
        <After><![CDATA[sb.Append(s).Append("x");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1198</Id>
    <Identifier>AvoidBoxingOfValueType</Identifier>
    <Title>Avoid unnecessary boxing of value type</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = null;
int i = 0;

// ...

string x = s + i;]]></Before>
        <After><![CDATA[string x = s + i.ToString();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1199</Id>
    <Identifier>UnnecessaryNullCheck</Identifier>
    <Title>Unnecessary null check</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool? x = null;

// ...

if (x.HasValue && x.Value)
{
}]]></Before>
        <After><![CDATA[if (x == true)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool? x = null;
bool y = false;

// ...

if (x != null && x.Value == y)
{
}]]></Before>
        <After><![CDATA[if (x == y)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1200</Id>
    <Identifier>CallThenByInsteadOfOrderBy</Identifier>
    <Title>Call 'Enumerable.ThenBy' instead of 'Enumerable.OrderBy'</Title>
    <MessageFormat>Call 'Enumerable.ThenBy{0}' instead of 'Enumerable.OrderBy{0}'</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.OrderBy(f => f.Surname).OrderBy(f => f.Name);]]></Before>
        <After><![CDATA[var x = items.OrderBy(f => f.Surname).ThenBy(f => f.Name);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1201</Id>
    <Identifier>UseMethodChaining</Identifier>
    <Title>Use method chaining</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[sb = new StringBuilder();

sb.Append("a");
sb.Append("b");
sb.Append("c");]]></Before>
        <After><![CDATA[sb = new StringBuilder();

sb.Append("a")
    .Append("b")
    .Append("c");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1202</Id>
    <Identifier>AvoidNullReferenceException</Identifier>
    <Title>Avoid NullReferenceException</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = items.FirstOrDefault().ToString();]]></Before>
        <After><![CDATA[string s = items.FirstOrDefault()?.ToString();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1203</Id>
    <Identifier>UseAttributeUsageAttribute</Identifier>
    <Title>Use AttributeUsageAttribute</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class FooAttribute : Attribute
{
}]]></Before>
        <After><![CDATA[[AttributeUsageAttribute(AttributeTargets.All, AllowMultiple = false)]
public class FooAttribute : Attribute
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1204</Id>
    <Identifier>UseEventArgsEmpty</Identifier>
    <Title>Use EventArgs.Empty</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = new EventArgs();]]></Before>
        <After><![CDATA[var x = EventArgs.Empty;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1205</Id>
    <Identifier>OrderNamedArguments</Identifier>
    <Title>Order named arguments according to the order of parameters</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using (var sm = new StreamReader(
    stream: default(Stream),
    encoding: Encoding.UTF8,
    bufferSize: 0,
    leaveOpen: false,
    detectEncodingFromByteOrderMarks: true))
{
}]]></Before>
        <After><![CDATA[using (var sm = new StreamReader(
    stream: default(Stream),
    encoding: Encoding.UTF8,
    detectEncodingFromByteOrderMarks: true,
    bufferSize: 0,
    leaveOpen: false))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1206</Id>
    <Identifier>UseConditionalAccessInsteadOfConditionalExpression</Identifier>
    <Title>Use conditional access instead of conditional expression</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = new Foo();

// ...

        string s = (x != null) ? x.ToString() : null;]]></Before>
        <After><![CDATA[string s = x?.ToString();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[int? x = null;

// ...

int i = (x != null) ? x.Value.GetHashCode() : 0;]]></Before>
        <After><![CDATA[int i = x?.GetHashCode() ?? 0;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1207</Id>
    <Identifier>UseAnonymousFunctionOrMethodGroup</Identifier>
    <Title>Use anonymous function or method group</Title>
    <MessageFormat>Use {0}</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.Select(f => Foo(f));]]></Before>
        <After><![CDATA[var x = items.Select(Foo);]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="use_anonymous_function_or_method_group" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1208</Id>
    <Identifier>ReduceIfNesting</Identifier>
    <Title>Reduce 'if' nesting</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition1)
{
    Foo1();

    if (condition2)
    {
        Foo2();

        if (condition3)
        {
            Foo3();
        }
    }
}]]></Before>
        <After><![CDATA[if (!condition1)
{
    return;
}

Foo1();

if (!condition2)
{
    return;
}

Foo2();

if (!condition3)
{
    return;
}

Foo3();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1209</Id>
    <Identifier>OrderTypeParameterConstraints</Identifier>
    <Title>Order type parameter constraints</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo<T1, T2, T3>
    where T3 : class
    where T2 : class
    where T1 : class
{
}]]></Before>
        <After><![CDATA[public class Foo<T1, T2, T3>
    where T1 : class
    where T2 : class
    where T3 : class
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1210</Id>
    <Identifier>ReturnCompletedTaskInsteadOfNull</Identifier>
    <Title>Return completed task instead of returning null</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Task<object> GetAsync()
{
    return null;
}]]></Before>
        <After><![CDATA[Task<object> GetAsync()
{
    return Task.FromResult<object>(null);
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[Task<object> GetAsync()
{
    return _foo?.GetAsync();
}]]></Before>
        <After><![CDATA[Task<object> GetAsync()
{
    Foo x = _foo;
    if (x != null)
    {
        return _foo.GetAsync();
    }
    else
    {
        return Task.FromResult<object>(null);
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1211</Id>
    <Identifier>RemoveUnnecessaryElse</Identifier>
    <Title>Remove unnecessary 'else'</Title>
    <MessageFormat>Remove unnecessary else clause</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    return WhenTrue();
}
else
{
    return WhenFalse();
}]]></Before>
        <After><![CDATA[if (condition)
{
    return WhenTrue();
}

return WhenFalse();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1212</Id>
    <Identifier>RemoveRedundantAssignment</Identifier>
    <Title>Remove redundant assignment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[string x;
x = "";]]></Before>
        <After><![CDATA[string x = "";]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool M()
{
    // ...

    x = false;
    return x;
}]]></Before>
        <After><![CDATA[bool M()
{
    // ...

    return false;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1213</Id>
    <Identifier>RemoveUnusedMemberDeclaration</Identifier>
    <Title>Remove unused member declaration</Title>
    <MessageFormat>Remove unused {0} declaration</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <ConfigOptions>
      <Option Key="unity_code_analysis.enabled" />
      <Option Key="suppress_unity_script_methods" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1214</Id>
    <Identifier>UnnecessaryInterpolatedString</Identifier>
    <Title>Unnecessary interpolated string</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"abc";]]></Before>
        <After><![CDATA[string s = "abc";]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[$"{NonNullStringConstant}"]]></Before>
        <After><![CDATA[NonNullStringConstant]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1215</Id>
    <Identifier>ExpressionIsAlwaysEqualToTrueOrFalse</Identifier>
    <Title>Expression is always equal to true/false</Title>
    <MessageFormat>Expression is always equal to '{0}'</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[uint i = 0;

// ...

if (i >= 0)
{
}]]></Before>
      </Sample>
      <Sample>
        <Before><![CDATA[var items = new List<object>();

// ...


if (items.Count < 0)
{
}]]></Before>
      </Sample>
      <Sample>
        <Before><![CDATA[x == double.NaN]]></Before>
        <After><![CDATA[double.IsNaN(x)]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1216</Id>
    <Identifier>UnnecessaryUnsafeContext</Identifier>
    <Title>Unnecessary unsafe context</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public unsafe class Foo
{
    public Foo()
    {
        unsafe
        {
            Bar();
        }
    }

    private unsafe void Bar()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    public Foo()
    {
        Bar();
    }

    private void Bar()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1217</Id>
    <Identifier>ConvertInterpolatedStringToConcatenation</Identifier>
    <Title>Convert interpolated string to concatenation</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[$"{a}{b}{c}"]]></Before>
        <After><![CDATA[a + b + c]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1218</Id>
    <Identifier>SimplifyCodeBranching</Identifier>
    <Title>Simplify code branching</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
}
else
{
  M();
}]]></Before>
        <After><![CDATA[if (!x)
{
  M();
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[while (true)
{
  if (x)
  {
    M();
  }
  else
  {
    break;
  }
}]]></Before>
        <After><![CDATA[while (x)
{
  M();
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[while (true)
{
  if (x)
  {
    break;
  }

  M();
}]]></Before>
        <After><![CDATA[while (!x)
{
  M();
      
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[do
{
  M();

  if (x)
  {
    break;
  }
  
} while (true);]]></Before>
        <After><![CDATA[do
{
  M();

} while (!x);]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x)
{
  do
  {
    M();
  }
  while (x);]]></Before>
        <After><![CDATA[while (x)
{
  M();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1219</Id>
    <Identifier>CallSkipAndAnyInsteadOfCount</Identifier>
    <Status>Disabled</Status>
    <Title>Call 'Enumerable.Skip' and 'Enumerable.Any' instead of 'Enumerable.Count'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (enumerable.Count() > x)
{
}]]></Before>
        <After><![CDATA[if (enumerable.Skip(x).Any())
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1220</Id>
    <Identifier>UsePatternMatchingInsteadOfIsAndCast</Identifier>
    <Title>Use pattern matching instead of combination of 'is' operator and cast operator</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>7.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x is T && Foo((T)x))
{
}]]></Before>
        <After><![CDATA[if (x is T y && Foo(y))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1221</Id>
    <Identifier>UsePatternMatchingInsteadOfAsAndNullCheck</Identifier>
    <Title>Use pattern matching instead of combination of 'as' operator and null check</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>7.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = x as Foo;

if (y == null)
{
    return;
}]]></Before>
        <After><![CDATA[if (!(x is Foo y))
{
    return;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1222</Id>
    <Identifier>MergePreprocessorDirectives</Identifier>
    <Title>Merge preprocessor directives</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[#pragma warning disable CS0000
#pragma warning disable CS0001
]]></Before>
        <After><![CDATA[#pragma warning disable CS0000, CS0001]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1223</Id>
    <Identifier>MarkTypeWithDebuggerDisplayAttribute</Identifier>
    <Title>Mark publicly visible type with DebuggerDisplay attribute</Title>
    <MessageFormat>Mark '{0}' with DebuggerDisplay attribute</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
}]]></Before>
        <After><![CDATA[[DebuggerDisplay("{DebuggerDisplay,nq}")]
public class Foo
{
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private string DebuggerDisplay
    {
        get { return ToString(); }
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1224</Id>
    <Identifier>MakeMethodExtensionMethod</Identifier>
    <Title>Make method an extension method</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>Public/internal method in public/internal static class whose name ends with "Extensions" should be an extension method.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[public static class FooExtensions
{
    public static string Bar(Foo foo)
    {
    }
}]]></Before>
        <After><![CDATA[public static class FooExtensions
{
    public static string Bar(this Foo foo)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1225</Id>
    <Identifier>MakeClassSealed</Identifier>
    <Title>Make class sealed</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>A class that has only private constructors should be marked as sealed.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public sealed class Foo
{
    private Foo()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1226</Id>
    <Identifier>AddParagraphToDocumentationComment</Identifier>
    <Title>Add paragraph to documentation comment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// summary1
/// 
/// summary2
/// summary3
/// </summary>
class Foo
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// <para>summary1</para>
/// <para>
/// summary2
/// summary3
/// </para>
/// </summary>
class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1227</Id>
    <Identifier>ValidateArgumentsCorrectly</Identifier>
    <Title>Validate arguments correctly</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>
      An iterator method (a method that contains `yield`) will not validate arguments until the caller begins to enumerate the result items.

      To ensure that arguments are validated immediately (when the method is called), move
      the iterator to a separate method (local function).
    </Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> Foo(IEnumerable<object> items)
{
    if (items == null)
        throw new ArgumentNullException(nameof(items));

    foreach (object item in items)
        yield return item;
}]]></Before>
        <After><![CDATA[IEnumerable<object> Foo(IEnumerable<object> items)
{
    if (items == null)
        throw new ArgumentNullException(nameof(items));

    return FooIterator();

    IEnumerable<object> FooIterator()
    {
        foreach (object item in items)
            yield return item;    
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1228</Id>
    <Identifier>UnusedElementInDocumentationComment</Identifier>
    <Title>Unused element in a documentation comment</Title>
    <MessageFormat>Unused '{0}' element in a documentation comment</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// 
/// </summary>
/// <returns></returns>
public string Foo()
{
    return null;
}
]]></Before>
        <After><![CDATA[/// <summary>
/// 
/// </summary>
public string Foo()
{
    return null;
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1229</Id>
    <Identifier>UseAsyncAwait</Identifier>
    <Title>Use async/await when necessary</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Task<object> FooAsync()
{
    using (var service = CreateService())
    {
        return service.GetAsync();
    }
}
]]></Before>
        <After><![CDATA[async Task<object> FooAsync()
{
    using (var service = CreateService())
    {
        return await service.GetAsync();
    }
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>http://thebillwagner.com/Blog/Item/2017-05-03-ThecuriouscaseofasyncawaitandIDisposable</Url>
        <Text>The curious case of async, await, and IDisposable</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1230</Id>
    <Identifier>UnnecessaryExplicitUseOfEnumerator</Identifier>
    <Title>Unnecessary explicit use of enumerator</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using (var en = items.GetEnumerator())
{
    while (en.MoveNext())
    {
        yield return en.Current;
    }
}]]></Before>
        <After><![CDATA[foreach (var item in items)
{
    yield return item;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1231</Id>
    <Identifier>MakeParameterRefReadOnly</Identifier>
    <Title>Make parameter ref read-only</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>7.2</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[readonly struct C
{
    void M(C c)
    {
    }
}]]></Before>
        <After><![CDATA[readonly struct C
{
    void M(in C c)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1232</Id>
    <Identifier>OrderElementsInDocumentationComment</Identifier>
    <Title>Order elements in documentation comment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    /// <summary></summary>
    /// <param name="p3"></param>
    /// <param name="p2"></param>
    /// <param name="p1"></param>
    void M(object p1, object p2, object p3)
    {
    }
}]]></Before>
        <After><![CDATA[class C
{
    /// <summary></summary>
    /// <param name="p1"></param>
    /// <param name="p2"></param>
    /// <param name="p3"></param>
    void M(object p1, object p2, object p3)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1233</Id>
    <Identifier>UseShortCircuitingOperator</Identifier>
    <Title>Use short-circuiting operator</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[boolExpr1 & boolExpr2]]></Before>
        <After><![CDATA[boolExpr1 && boolExpr2]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[boolExpr1 | boolExpr2]]></Before>
        <After><![CDATA[boolExpr1 || boolExpr2]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1234</Id>
    <Identifier>DuplicateEnumValue</Identifier>
    <Title>Duplicate enum value</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum E
{
    A = 1,
    B = 2,
    C = 2,
}]]></Before>
        <After><![CDATA[enum E
{
    A = 1,
    B = 2,
    C = B,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1235</Id>
    <Identifier>OptimizeMethodCall</Identifier>
    <Title>Optimize method call</Title>
    <MessageFormat>Optimize '{0}' call</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string.Compare(x, y, StringComparison.Ordinal)]]></Before>
        <After><![CDATA[string.CompareOrdinal(x, y)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string.Compare(x, y, StringComparison.CurrentCulture) == 0]]></Before>
        <After><![CDATA[string.Equals(x, y, StringComparison.CurrentCulture)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string.Join("", x, z, y)]]></Before>
        <After><![CDATA[string.Concat(x, y, z)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[Debug.Assert(false, "message");]]></Before>
        <After><![CDATA[Debug.Fail("message");]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (dic.ContainsKey(key))
{
  dic[key] = value;
}
else
{
  dic.Add(key, value);
}]]></Before>
        <After><![CDATA[dic[key] = value;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1236</Id>
    <Identifier>UseExceptionFilter</Identifier>
    <Title>Use exception filter</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
}
catch (Exception ex)
{
    if (!(ex is InvalidOperationException))
    {
        throw;
    }

    return;
}]]></Before>
        <After><![CDATA[try
{
}
catch (Exception ex) when (ex is InvalidOperationException)
{
    return;
}]]></After>
      </Sample>
    </Samples>
    <Remarks>The accepted [answer](https://stackoverflow.com/a/28879616) from Stack Overflow states:
&gt;"If there is an exception thrown within the filter, then that exception will be silently swallowed and the filter simply fails."

It is impossible to definitely detect if an exception can be thrown within an expression.

So the expression is considered as the one that can throw an exception if it contains method call that meets one of the following requirements:

* Its name starts with `ThrowIf`.
* Its XML comment contains `&lt;exception&gt;` element.</Remarks>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#exception-filters</Url>
        <Text>What's New in C# 6.0 - Exception Filters</Text>
      </Link>
      <Link>
        <Url>https://thomaslevesque.com/2015/06/21/exception-filters-in-c-6/</Url>
        <Text>Exception filters in C# 6: their biggest advantage is not what you think</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1237</Id>
    <Identifier>UseBitShiftOperator</Identifier>
    <Status>Obsolete</Status>
    <ObsoleteMessage>Use RCS1254 instead</ObsoleteMessage>
    <Title>Use bit shift operator</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
enum Foo
{
    None = 0,
    Alpha = 1,
    Beta = 2,
    Gamma = 4,
}]]></Before>
        <After><![CDATA[[Flags]
enum Foo
{
    None = 0,
    Alpha = 1,
    Beta = 1 << 1,
    Gamma = 1 << 2,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1238</Id>
    <Identifier>AvoidNestedConditionalOperators</Identifier>
    <Title>Avoid nested ?: operators</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = (a) ? "a" : (b) ? "b" : "c";]]></Before>
        <After><![CDATA[var x;
if (a)
{
    x = "a";
}
else if (b)
{
    x = "b";
}
else
{
    x = "c";
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1239</Id>
    <Identifier>UseForStatementInsteadOfWhileStatement</Identifier>
    <Title>Use 'for' statement instead of 'while' statement</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[int i = 0;
while (x)
{
    M();
    i++;
}]]></Before>
        <After><![CDATA[for (int i = 0; x; i++)
{
    M();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1240</Id>
    <Identifier>UnnecessaryOperator</Identifier>
    <Title>Operator is unnecessary</Title>
    <MessageFormat>The '{0}' operator is unnecessary</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[array.Length <= 0]]></Before>
        <After><![CDATA[array.Length == 0]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1241</Id>
    <Identifier>ImplementNonGenericCounterpart</Identifier>
    <Title>Implement non-generic counterpart</Title>
    <MessageFormat>Implement {0} when implementing {1}&lt;T&gt;</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>Publicly visible type that implements `IComparable&lt;T&gt;`, `IComparer&lt;T&gt;` or `IEqualityComparer&lt;T&gt;` should implement their non-generic counterpart.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparable : IComparable<C>
{
    public abstract int CompareTo(C other);
}]]></Before>
        <After><![CDATA[using System;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparable : IComparable<C>, IComparable
{
    public abstract int CompareTo(C other);

    public int CompareTo(object obj)
    {
        if (obj == null)
        {
            return 1;
        }

        if (obj is C x)
        {
            return CompareTo(x);
        }

        throw new ArgumentException("""", nameof(obj));
    }
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparer : IComparer<C>
{
    public abstract int Compare(C x, C y);
}]]></Before>
        <After><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparer : IComparer<C>, IComparer
{
    public abstract int Compare(C x, C y);

    public int Compare(object x, object y)
    {
        if (x == y)
        {
            return 0;
        }

        if (x == null)
        {
            return -1;
        }

        if (y == null)
        {
            return 1;
        }

        if (x is global::C a
            && y is global::C b)
        {
            return Compare(a, b);
        }

        if (x is IComparable ic)
        {
            return ic.CompareTo(y);
        }

        throw new ArgumentException("""", nameof(x));
    }
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class EqualityComparer : IEqualityComparer<C>
{
    public abstract bool Equals(C x, C y);

    public abstract int GetHashCode(C obj);
}]]></Before>
        <After><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class EqualityComparer : IEqualityComparer<C>, IEqualityComparer
{
    public abstract bool Equals(C x, C y);

    public abstract int GetHashCode(C obj);

    new public bool Equals(object x, object y)
    {
        if (x == y)
        {
            return true;
        }

        if (x == null || y == null)
        {
            return false;
        }

        if (x is global::C a
            && y is global::C b)
        {
            return Equals(a, b);
        }

        return x.Equals(y);
    }

    public int GetHashCode(object obj)
    {
        if (obj == null)
        {
            throw new ArgumentNullException(nameof(obj));
        }

        if (obj is C x)
        {
            return GetHashCode(x);
        }

        return obj.GetHashCode();
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1242</Id>
    <Identifier>DoNotPassNonReadOnlyStructByReadOnlyReference</Identifier>
    <Title>Do not pass non-read-only struct by read-only reference</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>7.2</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[struct C
{
    void M(in C c)
    {
    }
}]]></Before>
        <After><![CDATA[struct C
{
    void M(C c)
    {
    }
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/in-parameter-modifier</Url>
        <Text>in parameter modifier (C# Reference)</Text>
      </Link>
      <Link>
        <Url>https://devblogs.microsoft.com/premier-developer/the-in-modifier-and-the-readonly-structs-in-c/</Url>
        <Text>The 'in'-modifier and the readonly structs in C#</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1243</Id>
    <Identifier>DuplicateWordInComment</Identifier>
    <Title>Duplicate word in a comment</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// This is the the comment.
/// </summary>
public class C
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// This is the comment.
/// </summary>
public class C
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1244</Id>
    <Identifier>SimplifyDefaultExpression</Identifier>
    <Title>Simplify 'default' expression</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>7.1</MinLanguageVersion>
    <Summary>This analyzer is similar to [IDE0034](https://docs.microsoft.com/visualstudio/ide/common-quick-actions#remove-type-from-default-value-expression) but there are some differences. For example this analyzer does not simplify 'default' expression passed as an argument expression.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo M(Foo foo = default(Foo))
{
    return default(Foo);
}]]></Before>
        <After><![CDATA[Foo M(Foo foo = default)
{
    return default;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1245</Id>
    <Identifier>SimplifyConditionalExpression2</Identifier>
    <Status>Disabled</Status>
    <Title>Simplify conditional expression</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool x = y ? false : z;]]></Before>
        <After><![CDATA[bool x = !y && z;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? z : true;]]></Before>
        <After><![CDATA[bool x = !y || z;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1246</Id>
    <Identifier>UseElementAccess</Identifier>
    <Title>Use element access</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>8.0 for [^1]</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[list.First()]]></Before>
        <After><![CDATA[list[0]]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[list.ElementAt(1)]]></Before>
        <After><![CDATA[list[1]]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[list.Last()]]></Before>
        <After><![CDATA[list[^1]]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1247</Id>
    <Identifier>FixDocumentationCommentTag</Identifier>
    <Title>Fix documentation comment tag</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// <code>null</code>
/// </summary>
void M()
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// <c>null<c>
/// </summary>
void M()
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[/// <summary>
/// <c>
/// if (x == null)
///     x = new object();
/// </c>
/// </summary>
void M()
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// <code>
/// if (x == null)
///     x = new object();
/// </code>
/// </summary>
void M()
{
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/dotnet/csharp/programming-guide/xmldoc/recommended-tags-for-documentation-comments</Url>
        <Text>Recommended tags for documentation comments (C# programming guide)</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1248</Id>
    <Identifier>NormalizeNullCheck</Identifier>
    <Title>Normalize null check</Title>
    <MessageFormat>Use {0} to check for null</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>7.0 (9.0 for 'is not null' syntax)</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[x == null]]></Before>
        <After><![CDATA[x is null]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="null_check_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1249</Id>
    <Identifier>UnnecessaryNullForgivingOperator</Identifier>
    <Title>Unnecessary null-forgiving operator</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>8.0</MinLanguageVersion>
  </Analyzer>
  <Analyzer>
    <Id>RCS1250</Id>
    <Identifier>UseImplicitOrExplicitObjectCreation</Identifier>
    <Title>Use implicit/explicit object creation</Title>
    <MessageFormat>{0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>9.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[private string _value = new string(' ', 1)]]></Before>
        <After><![CDATA[private string _value = new(' ', 1)]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="object_creation_type_style" IsRequired="true" />
      <Option Key="use_var_instead_of_implicit_object_creation" />
      <Option Key="use_collection_expression" />
    </ConfigOptions>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/target-typed-new</Url>
        <Text>Target-typed new expressions</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1251</Id>
    <Identifier>RemoveUnnecessaryBraces</Identifier>
    <Title>Remove unnecessary braces from record declaration</Title>
    <MessageFormat>Remove unnecessary braces</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public record Foo(string Value1, string Value2)
{
}]]></Before>
        <After><![CDATA[public record Foo(string Value1, string Value2);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1252</Id>
    <Identifier>NormalizeUsageOfInfiniteLoop</Identifier>
    <Title>Normalize usage of infinite loop</Title>
    <MessageFormat>Use '{0}' statement as an infinite loop</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="infinite_loop_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1253</Id>
    <Identifier>FormatDocumentationCommentSummary</Identifier>
    <Title>Format documentation comment summary</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer replaces RCS1100 and RCS1101.</Summary>
    <ConfigOptions>
      <Option Key="doc_comment_summary_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1254</Id>
    <Identifier>NormalizeFormatOfEnumFlagValue</Identifier>
    <Title>Normalize format of enum flag value</Title>
    <MessageFormat>{0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="enum_flag_value_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1255</Id>
    <Identifier>SimplifyArgumentNullCheck</Identifier>
    <Title>Simplify argument null check</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>Use `ArgumentNullException.ThrowIfNull` instead of `if` null check.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[if (arg is null)
{
    throw new ArgumentNullException(nameof(arg));
}]]></Before>
        <After><![CDATA[ArgumentNullException.ThrowIfNull(arg);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1256</Id>
    <Identifier>InvalidArgumentNullCheck</Identifier>
    <Title>Invalid argument null check</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>This analyzer reports null checks of arguments that are:
- annotated as nullable reference type.
- optional and its default value is `null`.
    </Summary>
  </Analyzer>
  <Analyzer Identifier="UseEnumFieldExplicitly">
    <Id>RCS1257</Id>
    <Title>Use enum field explicitly</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var options = (RegexOptions) 1]]></Before>
        <After><![CDATA[var options = RegexOptions.IgnoreCase]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryEnumFlag" IsDevelopment="true">
    <Id>RCS1258</Id>
    <Title>Unnecessary enum flag</Title>
    <MessageFormat>Enum flag '{0}' is already contained in flag '{1}'</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var styles = NumberStyles.Integer | NumberStyles.AllowLeadingWhite]]></Before>
        <After><![CDATA[var styles = NumberStyles.Integer]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1259</Id>
    <Identifier>RemoveEmptySyntax</Identifier>
    <Title>Remove empty syntax</Title>
    <MessageFormat>Remove empty {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Summary>This analyzer reports unnecessary syntax that can be safely removed such as:
  * empty destructor
  * empty `else` clause
  * empty `finally` clause
  * empty `namespace` declaration
  * empty object initializer
  * empty `#region`
  * empty statement
</Summary>
  </Analyzer>
  <Analyzer>
    <Id>RCS1260</Id>
    <Identifier>AddOrRemoveTrailingComma</Identifier>
    <Title>Add/remove trailing comma</Title>
    <MessageFormat>{0} trailing comma</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="trailing_comma_style" IsRequired="true" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <ConfigOptions>
          <Option Key="trailing_comma_style" Value="include" />
        </ConfigOptions>
        <Before><![CDATA[public enum Foo
{
    A,
    B,
    C
}]]></Before>
        <After><![CDATA[public enum Foo
{
    A,
    B,
    C,
}]]></After>
      </Sample>
      <Sample>
        <ConfigOptions>
          <Option Key="trailing_comma_style" Value="omit_when_single_line" />
        </ConfigOptions>
        <Before><![CDATA[public enum Foo { A, B, C, }]]></Before>
        <After><![CDATA[public enum Foo { A, B, C }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1261</Id>
    <Identifier>DisposeResourceAsynchronously</Identifier>
    <Title>Resource can be disposed asynchronously</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[async Task FooAsync()
{
    using var disposable = await GetDisposableAsync();
}
]]></Before>
        <After><![CDATA[async Task FooAsync()
{
    await using var disposable = await GetDisposableAsync();
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1262</Id>
    <Identifier>UnnecessaryRawStringLiteral</Identifier>
    <Title>Unnecessary raw string literal</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>11.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = """foo""";]]></Before>
        <After><![CDATA[string s = "foo";]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://learn.microsoft.com/dotnet/csharp/language-reference/tokens/raw-string</Url>
        <Text>Raw string literal text - """ in string literals</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer>
    <Id>RCS1263</Id>
    <Identifier>InvalidReferenceInDocumentationComment</Identifier>
    <Title>Invalid reference in a documentation comment</Title>
    <MessageFormat>{0} '{1}' could not be found</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// 
/// </summary>
/// <param name="barr"></param>
public string Foo(string bar)
{
   /// ...
}
]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1264</Id>
    <Identifier>UseVarOrExplicitType</Identifier>
    <Title>Use 'var' or explicit type</Title>
    <MessageFormat>{0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="use_var" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer>
    <Id>RCS1265</Id>
    <Identifier>RemoveRedundantCatchBlock</Identifier>
    <Title>Remove redundant catch block</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[
try
{
   DoSomething();
}
catch
{
   throw;
}
finally
{
   DoSomethingElse();
}
]]></Before>
        <After><![CDATA[
try
{
   DoSomething();
}
finally
{
   DoSomethingElse();
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1266</Id>
    <Identifier>UseRawStringLiteral</Identifier>
    <Title>Use raw string literal</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[
string s = @"
  ""foo""
";
]]></Before>
        <After><![CDATA[
string s = """

  "foo"

""";
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1267</Id>
    <Identifier>UseStringInterpolationInsteadOfStringConcat</Identifier>
    <Title>Use string interpolation instead of 'string.Concat'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var s = string.Concat("Id: ", id, ", Value: ", value);]]></Before>
        <After><![CDATA[var s = $"Id: {id}, Value: {value}";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS1268</Id>
    <Identifier>SimplifyNumericComparison</Identifier>
    <Title>Simplify numeric comparison</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Description>Simplifies comparisons that involve subtracting two values and comparing the result to zero.</Description>
    <Samples>
      <Sample>
        <Before><![CDATA[(a - b) == 0]]></Before>
        <After><![CDATA[a == b]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[(a - b) > 0]]></Before>
        <After><![CDATA[a > b]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[(a - b) >= 0]]></Before>
        <After><![CDATA[a >= b]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[(a - b) < 0]]></Before>
        <After><![CDATA[a < b]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[(a - b) <= 0]]></Before>
        <After><![CDATA[a <= b]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9001</Id>
    <Identifier>UsePatternMatching</Identifier>
    <Title>Use pattern matching</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (syntaxNode.IsKind(SyntaxKind.IdentifierName))
{
    var identifierName = (IdentifierNameSyntax)syntaxNode;
}]]></Before>
        <After><![CDATA[if (syntaxNode is IdentifierNameSyntax identifierName)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (!syntaxNode.IsKind(SyntaxKind.IdentifierName))
{
    return;
}

var identifierName = (IdentifierNameSyntax)syntaxNode;
]]></Before>
        <After><![CDATA[if (!(syntaxNode is IdentifierNameSyntax identifierName))
{
  return;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9002</Id>
    <Identifier>UsePropertySyntaxNodeSpanStart</Identifier>
    <Title>Use property SyntaxNode.SpanStart</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[node.Span.Start]]></Before>
        <After><![CDATA[node.SpanStart]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9003</Id>
    <Identifier>UnnecessaryConditionalAccess</Identifier>
    <Title>Unnecessary conditional access</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[node?.IsKind(kind) == true]]></Before>
        <After><![CDATA[node.IsKind(kind)]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9004</Id>
    <Identifier>CallAnyInsteadOfAccessingCount</Identifier>
    <Title>Call 'Any' instead of accessing 'Count'</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxList.Count > 0]]></Before>
        <After><![CDATA[syntaxList.Any()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[syntaxList.Count == 0]]></Before>
        <After><![CDATA[!syntaxList.Any()]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer is applicable for following types:
* `Microsoft.CodeAnalysis.ChildSyntaxList`
* `Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxNodeOrTokenList`
* `Microsoft.CodeAnalysis.SyntaxTokenList`
* `Microsoft.CodeAnalysis.SyntaxTriviaList`</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS9005</Id>
    <Identifier>UnnecessaryNullCheck</Identifier>
    <Title>Unnecessary null check</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxNode != null && syntaxNode.IsKind(kind)]]></Before>
        <After><![CDATA[syntaxNode.IsKind(kind)]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9006</Id>
    <Identifier>UseElementAccess</Identifier>
    <Title>Use element access</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxList.First()]]></Before>
        <After><![CDATA[syntaxList[0]]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[triviaList.ElementAt(1)]]></Before>
        <After><![CDATA[triviaList[1]]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer is applicable for following types:
* `Microsoft.CodeAnalysis.ChildSyntaxList`
* `Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxNodeOrTokenList`
* `Microsoft.CodeAnalysis.SyntaxTokenList`
* `Microsoft.CodeAnalysis.SyntaxTriviaList`</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS9007</Id>
    <Identifier>UseReturnValue</Identifier>
    <Title>Use return value</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[ifStatement.WithCondition(newCondition);]]></Before>
        <After><![CDATA[var x = ifStatement.WithCondition(newCondition);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9008</Id>
    <Identifier>CallLastInsteadOfUsingElementAccess</Identifier>
    <Title>Call 'Last' instead of using []</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxList[syntaxList.Count - 1]]]></Before>
        <After><![CDATA[syntaxList.Last()]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer is applicable for following types:
* `Microsoft.CodeAnalysis.ChildSyntaxList`
* `Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxNodeOrTokenList`
* `Microsoft.CodeAnalysis.SyntaxTokenList`
* `Microsoft.CodeAnalysis.SyntaxTriviaList`</Remarks>
  </Analyzer>
  <Analyzer>
    <Id>RCS9009</Id>
    <Identifier>UnknownLanguageName</Identifier>
    <Title>Unknown language name</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[DiagnosticAnalyzer("C")]
class FooDiagnosticAnalyzer : DiagnosticAnalyzer
{
}]]></Before>
        <After><![CDATA[[DiagnosticAnalyzer("C#")]
class FooDiagnosticAnalyzer : DiagnosticAnalyzer
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9010</Id>
    <Identifier>SpecifyExportCodeRefactoringProviderAttributeName</Identifier>
    <Title>Specify ExportCodeRefactoringProviderAttribute.Name</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[ExportCodeRefactoringProvider(LanguageNames.CSharp)]
class FooCodeRefactoringProvider : CodeRefactoringProvider
{
}]]></Before>
        <After><![CDATA[[ExportCodeRefactoringProvider(LanguageNames.CSharp, Name = nameof(FooCodeRefactoringProvider))]
class FooCodeRefactoringProvider : CodeRefactoringProvider
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer>
    <Id>RCS9011</Id>
    <Identifier>SpecifyExportCodeFixProviderAttributeName</Identifier>
    <Title>Specify ExportCodeFixProviderAttribute.Name</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[ExportCodeFixProvider(LanguageNames.CSharp)]
class FooCodeFixProvider : CodeFixProvider
{
}]]></Before>
        <After><![CDATA[[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(FooCodeFixProvider))]
class FooCodeFixProvider : CodeFixProvider
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
</Analyzers>